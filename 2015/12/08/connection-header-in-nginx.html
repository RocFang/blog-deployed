<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="strider (方鹏)">
<meta name="description" content="一个伪文青兼程序员的自嗨
    ">
<meta name="keywords" content="博客, 技术, 文学, 电影">
<meta name="referrer" content="always">
<title>Nginx 对 Connection 头的处理过程 - 纯真年代</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://pureage.info/">纯真年代</a></h1><h2><a href="https://pureage.info/">阅读、体验、沉淀...</a></h2>
  </div>
  <nav><a href="/">博客</a><a href="/tools/">工具</a><a href="/about/">关于</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>Nginx 对 Connection 头的处理过程</h1>
  </div>
<div class="meta">
  <div>2015-12-08</div>
  <div>
    <span><a href="/tags/nginx">#nginx</a></span>
    </div>
  </div>
<div class="content">
  <h3 id="1-标准">1. 标准</h3>
<p>RFC2616 中，对 Connection 的说明如下：</p>
<blockquote>
<p>HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option.</p>
</blockquote>
<p>综合 <a href="https://tools.ietf.org/html/rfc2616#page-117">RFC2626 14.10</a>、《HTTP权威指南》4.3.1、《图解HTTP》6.3.2中的说法，均指明了 Connection 头部（请求头、响应头）主要包括如下两方面的作用：</p>
<ol>
<li>控制不再转发给代理的首部字段</li>
<li>管理持久连接</li>
</ol>
<p>其中，我个人经常见到的是第二种用法，对第一种用法还不甚了解。</p>
<p>第一种用法，大概意思就是，在一个 HTTP 应用（客户端、服务器）将报文转发出之前，必须删除 Connection 首部列出的所有首部字段（多个不同的字段用逗号分隔），当然一些 end-to-end 的头部是肯定不能放进去的，例如 Cache-Control 头。</p>
<h3 id="2nginx-是如何做的">2.Nginx 是如何做的</h3>
<p>注：以下代码均来自 Nginx-1.8.0。</p>
<p>对于请求中的 Connection 头， Nginx 在 http 解析时调用 <code>ngx_http_process_connection</code> 方法：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#000">ngx_int_t</span>  
<span style="color:#000">ngx_http_process_connection</span>(<span style="color:#000">ngx_http_request_t</span> *<span style="color:#000">r</span>, <span style="color:#000">ngx_table_elt_t</span> *<span style="color:#000">h</span>,  
    <span style="color:#000">ngx_uint_t</span> <span style="color:#000">offset</span>)  
{  
    <span style="color:#00f">if</span> (<span style="color:#000">ngx_strcasestrn</span>(<span style="color:#000">h</span>-&gt;<span style="color:#000">value</span>.<span style="color:#000">data</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">close</span><span style="color:#5a2">&#34;</span>, <span style="color:#3af">5</span> - <span style="color:#3af">1</span>)) {  
        <span style="color:#000">r</span>-&gt;<span style="color:#000">headers_in</span>.<span style="color:#000">connection_type</span> = <span style="color:#000">NGX_HTTP_CONNECTION_CLOSE</span>;  
  
    } <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#000">ngx_strcasestrn</span>(<span style="color:#000">h</span>-&gt;<span style="color:#000">value</span>.<span style="color:#000">data</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">keep-alive</span><span style="color:#5a2">&#34;</span>, <span style="color:#3af">10</span> - <span style="color:#3af">1</span>)) {  
        <span style="color:#000">r</span>-&gt;<span style="color:#000">headers_in</span>.<span style="color:#000">connection_type</span> = <span style="color:#000">NGX_HTTP_CONNECTION_KEEP_ALIVE</span>;  
    }  
  
    <span style="color:#00f">return</span> <span style="color:#000">NGX_OK</span>;  
}  
</code></pre></div><p>可见，该方法主要功能只涉及到上面所述的 Connection 作用的第 2 个作用，而没有第 1 个。这应该算的上是实现对标准的支持不完整吧。</p>
<p>不管怎么样，我们继续分析一下 Nginx 在管理持久连接上具体是怎么做的，上面的代码逻辑很简单：</p>
<ol>
<li>如果 Connection 头是 close（不区分大小写），则 <code>r-&gt;headers_in.connection_type</code> 被置为 <code>NGX_HTTP_CONNECTION_CLOSE</code></li>
<li>如果 Connection 头是 keep-alive（不区分大小写），则 <code>r-&gt;headers_in.connection_type</code> 被设置为 <code>NGX_HTTP_CONNECTION_KEEP_ALIVE</code></li>
<li>如果不是以上两种情况，则什么都不做，此时 <code>r-&gt;headers_in.connection_type</code> 默认为 0。</li>
</ol>
<p>可以看到，<code>ngx_http_process_connection</code> 的作用仅仅是设置了一个标记 <code>r-&gt;headers_in.connection_type</code>，我们继续看这个标记是如何被使用的。</p>
<p>要想完整的讲述这个过程，不可避免需要涉及一些 Nginx 配置解析、解析 HTTP 协议相关的流程，但这些都不是本文的重点，下面均一笔带过。</p>
<p>Nginx 的各历史版本中，对于 http 协议解析的过程，细节稍微有些变化。在 Nginx-1.8.0 中，过程如下：</p>
<ol>
<li>
<p>我们知道，Nginx 是一个主进程加多子进程的架构，配置解析发生在 fork 子进程之前，在这个过程中很多操作都是对于全局变量 cycle 的操作。在 fork 之后，每个子进程均会继承一份这个全局变量 cycle（这里不考虑COW）。</p>
</li>
<li>
<p>http 配置解析的入口为 <code>ngx_http_block</code>，这是个很复杂的函数。因为 Nginx 的配置文件分层级，可以有包含关系，为了对这个特性提供支持，配置文件的解析涉及到配置项的内存布局的设计，最终落实下来，就是全局变量 cycle 的 <code>conf_ctx</code> 成员，这是个四重指针。配置解析的这部分是另一个话题，本文不打算细说。这里要关注的是，在 <code>ngx_http_block</code> 函数的最后，调用了 <code>ngx_http_optimize_servers</code> 方法，在这个方法里，完成了这样一个事情：配置文件里的监听套接字（可能是多个），最终被复制到了全局变量 <code>ngx_cycle</code> 的 <code>listening</code> 数组里。整个调用关系为，<code>nginx.c-&gt;main()-&gt;ngx_init_cycle-&gt;ngx_http_block(在 ngx_init_cycle里通过钩子被回调)-&gt;ngx_http_optimize_servers-&gt;ngx_http_init_listening-&gt;ngx_http_add_listening-&gt;ngx_create_listening</code>, 有兴趣的同学可以深入进去看看。</p>
</li>
<li>
<p>在上面的这个调用链里，<code>ngx_http_add_listening</code> 做了另外一个事情：将所有的<code>ngx_listening_t</code> 类型的监听套接字的 <code>handler</code> 钩子设置为 <code>ngx_http_init_connection</code>，这个在后面会用到。</p>
</li>
<li>
<p>nginx fork 出多个子进程，每个子进程会在 <code>ngx_worker_process_init</code> 方法里调用各个nginx 模块 <code>init_process</code> 钩子，其中当然也包括 <code>NGX_EVENT_MODULE</code> 类型的<code>ngx_event_core_module</code> 模块，其 <code>init_process</code> 钩子为 <code>ngx_event_process_init</code>。在<code>ngx_event_process_init</code> 里，每一个 <code>ngx_listening_t</code> 类型的监听套接字变量 <code>ls[i]</code>，根据 <code>ngx_get_connection</code> 从 nginx 的 <code>connections</code> 储备池里获得一个与之相关的 <code>ngx_connection_t</code> 类型的变量 <code>c</code> ,这两个变量均有一个指针成员指向对方，以此保持互相联系。从这里开始，我们将注意力转移到这个 <code>ngx_connection_t</code> 类型的变量 <code>c</code> 上。在 <code>ngx_event_process_init</code> 的后面，这个 <code>ngx_connection_t</code> 类型的变量的读事件的 <code>handler</code>，被置为 <code>ngx_event_accept</code>。然后这个读事件被添加到 epoll 中。</p>
</li>
<li>
<p>当一个请求来临时，<code>ngx_event_accpet</code> 被回调，其中上面第（3）步里为监听套接字设置的 <code>handler</code>，即 <code>ngx_http_init_connection</code> 被调用：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000">ls</span>-&gt;<span style="color:#000">handler</span>(<span style="color:#000">c</span>);  
</code></pre></div><p>这个调用非常有趣，<code>ls</code> 实质上是代表着监听套接字，而参数 <code>c</code> 则是 accept 后建立起来的连接套接字，根据 socket 的基本知识，该连接上后续客户端与 Nginx 之间的信息传输，都通过这个连接套接字上的读写来进行。</p>
</li>
<li>
<p>从 <code>ngx_http_init_connection</code> 开始，就着手进行一系列 HTTP 协议解析。中间涉及到<code>ngx_http_wait_request_handler</code>、<code>ngx_http_create_request</code>、<code>ngx_http_process_request_line</code>、<code>ngx_http_process_request_headers</code> 等解析方法。</p>
<p>似乎已经偏题太远了，我们回到最初的 Connection 请求头，在上面所讲的<code>ngx_http_process_connection</code> 中，根据 Connection 头，将 <code>r-&gt;headers_in.connection_type</code> 置为 <code>NGX_HTTP_CONNECTION_CLOSE</code>、<code>NGX_HTTP_CONNECTION_KEEP_ALIVE</code> 或者默认初始值 0。</p>
<p>那么这个过程发生在上面所述的一系列流程的哪个阶段呢？当然是发生在<code>ngx_http_process_request_headers</code> 里了，在个方法里，全局数组 <code>ngx_http_headers_in</code> 的对应元素的 <code>handler</code> 被调用，对于 Connection 请求头，就是 <code>ngx_http_process_connection</code> 了。</p>
<p>讲明白了 <code>ngx_http_process_connection</code> 发生的前因，我们再来看看后果。</p>
<p><code>ngx_http_process_connection</code> 的直接影响只有一个，即对  <code>r-&gt;headers_in.connection_type</code> 进行赋值，close 为 <code>NGX_HTTP_CONNECTION_CLOSE</code>，keep-alive 为 <code>NGX_HTTP_CONNECTION_KEEP_ALIVE</code>，其它情况为 0（初始值）。</p>
</li>
<li>
<p>在第（6）步里，在 <code>ngx_http_process_request_line</code> 方法调用完 <code>ngx_http_process_request_headers</code> 后，继续调用 <code>ngx_http_process_request</code>，进而开始正式的在业务上处理 HTTP 请求。<code>ngx_http_process_request</code> 的核心内容是对 <code>ngx_http_handler</code> 的调用。</p>
</li>
<li>
<p>在 <code>ngx_http_handler</code> 里，有这样一段代码：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">if</span> (!<span style="color:#000">r</span>-&gt;<span style="color:#000">internal</span>) {  
        <span style="color:#00f">switch</span> (<span style="color:#000">r</span>-&gt;<span style="color:#000">headers_in</span>.<span style="color:#000">connection_type</span>) {  
        <span style="color:#00f">case</span> <span style="color:#3af">0</span>:  
            <span style="color:#000">r</span>-&gt;<span style="color:#000">keepalive</span> = (<span style="color:#000">r</span>-&gt;<span style="color:#000">http_version</span> &gt; <span style="color:#000">NGX_HTTP_VERSION_10</span>);  
            <span style="color:#00f">break</span>;  
     
        <span style="color:#00f">case</span> <span style="color:#000">NGX_HTTP_CONNECTION_CLOSE</span>:  
            <span style="color:#000">r</span>-&gt;<span style="color:#000">keepalive</span> = <span style="color:#3af">0</span>;  
            <span style="color:#00f">break</span>;  
     
        <span style="color:#00f">case</span> <span style="color:#000">NGX_HTTP_CONNECTION_KEEP_ALIVE</span>:  
            <span style="color:#000">r</span>-&gt;<span style="color:#000">keepalive</span> = <span style="color:#3af">1</span>;  
            <span style="color:#00f">break</span>;  
        }  
     
        <span style="color:#000">r</span>-&gt;<span style="color:#000">lingering_close</span> = (<span style="color:#000">r</span>-&gt;<span style="color:#000">headers_in</span>.<span style="color:#000">content_length_n</span> &gt; <span style="color:#3af">0</span>  
                              || <span style="color:#000">r</span>-&gt;<span style="color:#000">headers_in</span>.<span style="color:#000">chunked</span>);  
        <span style="color:#000">r</span>-&gt;<span style="color:#000">phase_handler</span> = <span style="color:#3af">0</span>;  
     
    } <span style="color:#00f">else</span> {  
        <span style="color:#000">cmcf</span> = <span style="color:#000">ngx_http_get_module_main_conf</span>(<span style="color:#000">r</span>, <span style="color:#000">ngx_http_core_module</span>);  
        <span style="color:#000">r</span>-&gt;<span style="color:#000">phase_handler</span> = <span style="color:#000">cmcf</span>-&gt;<span style="color:#000">phase_engine</span>.<span style="color:#000">server_rewrite_index</span>;  
    }  
</code></pre></div><p>所以，到现在为止，客户端请求里带来的 Connection 头部，落在了 <code>r-&gt;keepalive</code> 上了。规则如下：</p>
<ul>
<li>如果 Connection 头部里为“close”，则 <code>r-&gt;keepalive</code> 为 0。</li>
<li>如果 Connection 头部里为“keep-alive”，则 r-&gt;keepalive为 1。</li>
<li>如果不是以上两种情况，则按照 HTTP 协议走默认情况：如果是 HTTP 1.0 以上，则 <code>r-&gt;keepalive</code> 默认为 1，如果是 HTTP 1.0及以下，则 <code>r-&gt;keepalive</code> 默认为 0。这一点是与 HTTP 协议相符合的。</li>
</ul>
<p>到目前为止，我们所讲的都算是 <code>r-&gt;keepalive</code> 是怎么产生的，还没有涉及到它是如何被使用的。</p>
<p><code>r-&gt;keepalive</code> 的使用主要是在函数 <code>ngx_http_finalize_connection</code> 中，而<code>ngx_http_finalize_connection</code> 在 Nginx 中，仅被 <code>ngx_http_finalize_request</code> 调用。顾名思义，<code>ngx_http_finalize_request</code> 讲的是怎么结束一个 HTTP 请求的。</p>
</li>
<li>
<p>在 <code>ngx_http_finalize_connection</code> 中，如果 r-&gt;keepalive 为 1，则会调用<code>ngx_http_set_keepalive</code> 并返回。<code>ngx_http_set_keepalive</code> 方法完成将当前连接设为 keepalive 状态的实质性工作。它实际上会把表示请求的 <code>ngx_http_request_t</code> 结构体释放，却又不会调用 <code>ngx_http_close_connection</code> 方法关闭连接，同时也在检测 keepalive 连接是否超时。</p>
</li>
</ol>
<p>至此，Connection 头部在 Nginx 里的处理流程差不多都讲完了，具体细节可按照这个脉络查看相应的代码。</p></div>

  </article>
</main>
<footer>
  <div>
    <div>2011-2020 strider. <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC-BY-4.0</a></div>
  </div>
</footer>
</body>
</html>
