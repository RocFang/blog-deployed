<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="strider (方鹏)">
<meta name="description" content="一个伪文青兼程序员的自嗨
    ">
<meta name="keywords" content="博客, 技术, 文学, 电影">
<meta name="referrer" content="always">
<title>accept与epoll惊群 - 纯真年代</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://pureage.info/">纯真年代</a></h1><h2><a href="https://pureage.info/">阅读、体验、沉淀...</a></h2>
  </div>
  <nav><a href="/">博客</a><a href="/tools/">工具</a><a href="/about/">关于</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>accept与epoll惊群</h1>
  </div>
<div class="meta">
  <div>2015-12-22</div>
  <div>
    <span><a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98">#程序员</a></span>
    <span><a href="/tags/nginx">#nginx</a></span>
    </div>
  </div>
<div class="content">
  <p>今天打开 OneNote,发现里面躺着一篇很久以前写的笔记，现在将它贴出来。</p>

<h2 id="1-什么叫惊群现象">1. 什么叫惊群现象</h2>

<p>首先，我们看看<a href="http://en.wikipedia.org/wiki/Thundering_herd_problem">维基百科对惊群的定义</a>:</p>

<blockquote>
<p>The thundering herd problem occurs when a large number of processes waiting for an event are awoken when that event occurs, but only one process is able to proceed at a time. After the processes wake up, they all demand the resource and a decision must be made as to which process can continue. After the decision is made, the remaining processes are put back to sleep, only to all wake up again to request access to the resource.</p>

<p>This occurs repeatedly, until there are no more processes to be woken up. Because all the processes use system resources upon waking, it is more efficient if only one process was woken up at a time.</p>

<p>This may render the computer unusable, but it can also be used as a technique if there is no other way to decide which process should continue (for example when programming with semaphores).</p>
</blockquote>

<p>简而言之，惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。</p>

<h2 id="2-accept-惊群">2. accept 惊群</h2>

<p>考虑如下场景：<br />
主进程创建socket, bind, listen之后，fork出多个子进程，每个子进程都开始循环处理（accept)这个socket。每个进程都阻塞在accpet上，当一个新的连接到来时，所有的进程都会被唤醒，但其中只有一个进程会accept成功，其余皆失败，重新休眠。这就是accept惊群。</p>

<p>那么这个问题真的存在吗？</p>

<p>事实上，历史上，Linux 的 accpet 确实存在惊群问题，但现在的内核都解决该问题了。即，当多个进程/线程都阻塞在对同一个 socket 的 accept 调用上时，当有一个新的连接到来，内核只会唤醒一个进程，其他进程保持休眠，压根就不会被唤醒。</p>

<p>测试代码如下：</p>

<pre><code>#include &lt;sys/types.h&gt;  
#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;  
#include &lt;sys/wait.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;  
#define PROCESS_NUM 10  
int main()  
{  
    int fd = socket(PF_INET, SOCK_STREAM, 0);  
    int connfd;  
    int pid;  
    char sendbuff[1024];  
    struct sockaddr_in serveraddr;  
    serveraddr.sin_family = AF_INET;  
    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);  
    serveraddr.sin_port = htons(1234);  
    bind(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr));  
    listen(fd, 1024);  
    int i;  
    for(i = 0; i &lt; PROCESS_NUM; i++)  
    {  
        int pid = fork();  
        if(pid == 0)  
        {  
            while(1)  
            {  
                connfd = accept(fd, (struct sockaddr*)NULL, NULL);  
                snprintf(sendbuff, sizeof(sendbuff), &quot;accept PID is %d\n&quot;, getpid());  
                
                send(connfd, sendbuff, strlen(sendbuff) + 1, 0);  
                printf(&quot;process %d accept success!\n&quot;, getpid());  
                close(connfd);  
            }  
        }  
    }  
    int status;  
    wait(&amp;status);  
    return 0;  
} 
</code></pre>

<p>当我们对该服务器发起连接请求（用 telnet/curl 等模拟）时，会看到只有一个进程被唤醒。</p>

<p>关于 accept 惊群的一些帖子或文章：</p>

<ul>
<li><a href="http://bbs.chinaunix.net/thread-946261-1-1.html">惊群问题在 linux 上可能是莫须有的问题</a><br /></li>
<li><a href="http://stackoverflow.com/questions/2213779/does-the-thundering-herd-problem-exist-on-linux-anymore">Does the Thundering Herd Problem exist on Linux anymore?</a><br /></li>
<li><a href="http://www.citi.umich.edu/projects/linux-scalability/reports/accept.html">历史上解决 linux accept 惊群的补丁讨论</a><br /></li>
</ul>

<h2 id="3-epoll惊群">3. epoll惊群</h2>

<p>如上所述，accept 已经不存在惊群问题，但 epoll 上还是存在惊群问题。即，如果多个进程/线程阻塞在监听同一个 listening socket fd 的 epoll_wait 上，当有一个新的连接到来时，所有的进程都会被唤醒。</p>

<p>考虑如下场景：</p>

<p>主进程创建 socket, bind， listen 后，将该 socket 加入到 epoll 中，然后 fork 出多个子进程，每个进程都阻塞在 epoll_wait 上，如果有事件到来，则判断该事件是否是该 socket 上的事件，如果是，说明有新的连接到来了，则进行 accept 操作。为了简化处理，忽略后续的读写以及对 accept 返回的新的套接字的处理，直接断开连接。</p>

<p>那么，当新的连接到来时，是否每个阻塞在 epoll_wait 上的进程都会被唤醒呢？</p>

<p>很多博客中提到，测试表明虽然 epoll_wait 不会像 accept 那样只唤醒一个进程/线程，但也不会把所有的进程/线程都唤醒。例如这篇文章：<a href="http://blog.163.com/pandalove@126/blog/static/9800324520122633515612">关于多进程 epoll 与 “惊群”问题</a>。</p>

<p>为了验证这个问题，我自己写了一个测试程序：</p>

<pre><code>#include &lt;sys/types.h&gt;  
#include &lt;sys/socket.h&gt;  
#include &lt;sys/epoll.h&gt;  
#include &lt;netdb.h&gt;  
#include &lt;string.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;fcntl.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;errno.h&gt;  
#include &lt;sys/wait.h&gt;  
#define PROCESS_NUM 10  
static int  
create_and_bind (char *port)  
{  
    int fd = socket(PF_INET, SOCK_STREAM, 0);  
    struct sockaddr_in serveraddr;  
    serveraddr.sin_family = AF_INET;  
    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);  
    serveraddr.sin_port = htons(atoi(port));  
    bind(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr));  
    return fd;  
}  
	static int  
make_socket_non_blocking (int sfd)  
{  
    int flags, s;  
 
    flags = fcntl (sfd, F_GETFL, 0);  
    if (flags == -1)  
    {  
        perror (&quot;fcntl&quot;);  
        return -1;  
    }  
 
    flags |= O_NONBLOCK;  
    s = fcntl (sfd, F_SETFL, flags);  
    if (s == -1)  
    {  
        perror (&quot;fcntl&quot;);  
        return -1;  
    }  
 
    return 0;  
}  
  
#define MAXEVENTS 64  
 
int  
main (int argc, char *argv[])  
{  
    int sfd, s;  
    int efd;  
    struct epoll_event event;  
    struct epoll_event *events;  
 
    sfd = create_and_bind(&quot;1234&quot;);  
    if (sfd == -1)  
        abort ();  
 
    s = make_socket_non_blocking (sfd);  
    if (s == -1)  
        abort ();  
 
    s = listen(sfd, SOMAXCONN);  
    if (s == -1)  
    {  
        perror (&quot;listen&quot;);  
        abort ();  
    }  
 
    efd = epoll_create(MAXEVENTS);  
    if (efd == -1)  
    {  
        perror(&quot;epoll_create&quot;);  
        abort();  
    }  
 
    event.data.fd = sfd;  
    //event.events = EPOLLIN | EPOLLET;  
    event.events = EPOLLIN;  
    s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &amp;event);  
    if (s == -1)  
    {  
        perror(&quot;epoll_ctl&quot;);  
        abort();  
    }  
 
    /* Buffer where events are returned */  
    events = calloc(MAXEVENTS, sizeof event);  
	        int k;  
    for(k = 0; k &lt; PROCESS_NUM; k++)  
    {  
        int pid = fork();  
        if(pid == 0)  
        {  
 
            /* The event loop */  
            while (1)  
            {  
                int n, i;  
                n = epoll_wait(efd, events, MAXEVENTS, -1);  
                printf(&quot;process %d return from epoll_wait!\n&quot;, getpid());  
	                                   /* sleep here is very important!*/  
                //sleep(2);  
	                                   for (i = 0; i &lt; n; i++)  
                {  
                    if ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp;                                    EPOLLIN)))  
                    {  
                        /* An error has occured on this fd, or the socket is not  
                        ready for reading (why were we notified then?) */  
                        fprintf (stderr, &quot;epoll error\n&quot;);  
                        close (events[i].data.fd);  
                        continue;  
                    }  
                    else if (sfd == events[i].data.fd)  
                    {  
                        /* We have a notification on the listening socket, which  
                        means one or more incoming connections. */  
                        struct sockaddr in_addr;  
                        socklen_t in_len;  
                        int infd;  
                        char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];  
 
                        in_len = sizeof in_addr;  
                        infd = accept(sfd, &amp;in_addr, &amp;in_len);  
                        if (infd == -1)  
                        {  
                            printf(&quot;process %d accept failed!\n&quot;, getpid());  
                            break;  
                        }  
                        printf(&quot;process %d accept successed!\n&quot;, getpid());  
 
                        /* Make the incoming socket non-blocking and add it to the  
                        list of fds to monitor. */  
                        close(infd); 
                    }  
                }  
            }  
        }  
    }  
    int status;  
    wait(&amp;status);  
    free (events);  
    close (sfd);  
    return EXIT_SUCCESS;  
}  
</code></pre>

<p>发现确实如上面那篇博客里所说，当我模拟发起一个请求时，只有一个或少数几个进程被唤醒了。</p>

<p>也就是说，到目前为止，还没有得到一个确定的答案。但后来，在下面这篇博客中看到这样一个评论：<a href="http://blog.csdn.net/spch2008/article/details/18301357">http://blog.csdn.net/spch2008/article/details/18301357</a></p>

<blockquote>
<p>这个总结，需要进一步阐述，你的实验，看上去是只有4个进程唤醒了，而事实上，其余进程没有被唤醒的原因是你的某个进程已经处理完这个 accept，内核队列上已经没有这个事件，无需唤醒其他进程。你可以在 epoll 获知这个 accept 事件的时候，不要立即去处理，而是 sleep 下，这样所有的进程都会被唤起</p>
</blockquote>

<p>看到这个评论后，我顿时如醍醐灌顶，重新修改了上面的测试程序，即在 epoll_wait 返回后，加了个 sleep 语句，这时再测试，果然发现所有的进程都被唤醒了。</p>

<p>所以，epoll_wait上的惊群确实是存在的。</p>

<h2 id="4-为什么内核不处理-epoll-惊群">4. 为什么内核不处理 epoll 惊群</h2>

<p>看到这里，我们可能有疑惑了，为什么内核对 accept 的惊群做了处理，而现在仍然存在 epoll 的惊群现象呢？</p>

<p>我想，应该是这样的：<br />
accept 确实应该只能被一个进程调用成功，内核很清楚这一点。但 epoll 不一样，他监听的文件描述符，除了可能后续被 accept 调用外，还有可能是其他网络 IO 事件的，而其他 IO 事件是否只能由一个进程处理，是不一定的，内核不能保证这一点，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。所以，对 epoll 的惊群，内核则不予处理。</p>

<h2 id="5-nginx-是如何处理惊群问题的">5. Nginx 是如何处理惊群问题的</h2>

<p>在思考这个问题之前，我们应该以前对前面所讲几点有所了解，即先弄清楚问题的背景，并能自己复现出来，而不仅仅只是看书或博客，然后再来看看 Nginx 的解决之道。这个顺序不应该颠倒。</p>

<p>首先，我们先大概梳理一下 Nginx 的网络架构，几个关键步骤为:</p>

<ol>
<li>Nginx 主进程解析配置文件，根据 listen 指令，将监听套接字初始化到全局变量 ngx_cycle 的 listening 数组之中。此时，监听套接字的创建、绑定工作早已完成。<br /></li>
<li>Nginx 主进程 fork 出多个子进程。<br /></li>
<li>每个子进程在 ngx_worker_process_init 方法里依次调用各个 Nginx 模块的 init_process 钩子，其中当然也包括 NGX_EVENT_MODULE 类型的 ngx_event_core_module 模块，其 init_process 钩子为 ngx_event_process_init。<br /></li>
<li>ngx_event_process_init 函数会初始化 Nginx 内部的连接池，并把 ngx_cycle 里的监听套接字数组通过连接池来获得相应的表示连接的 ngx_connection_t 数据结构，这里关于 Nginx 的连接池先略过。我们主要看 ngx_event_process_init 函数所做的另一个工作：如果在配置文件里<strong>没有</strong>开启<a href="http://nginx.org/en/docs/ngx_core_module.html#accept_mutex">accept_mutex锁</a>，就通过 ngx_add_event 将所有的监听套接字添加到 epoll 中。<br /></li>
<li>每一个 Nginx 子进程在执行完 ngx_worker_process_init 后，会在一个死循环中执行 ngx_process_events_and_timers，这就进入到事件处理的核心逻辑了。<br /></li>
<li>在 ngx_process_events_and_timers 中，如果在配置文件里开启了 accept_mutext 锁，子进程就会去获取 accet_mutext 锁。如果获取成功，则通过 ngx_enable_accept_events 将监听套接字添加到 epoll 中，否则，不会将监听套接字添加到 epoll 中，甚至有可能会调用 ngx_disable_accept_events 将监听套接字从 epoll 中删除（如果在之前的连接中，本worker子进程已经获得过accept_mutex锁)。<br /></li>
<li>ngx_process_events_and_timers 继续调用 ngx_process_events，在这个函数里面阻塞调用 epoll_wait。<br /></li>
</ol>

<p>至此，关于 Nginx 如何处理 fork 后的监听套接字，我们已经差不多理清楚了，当然还有一些细节略过了，比如在每个 Nginx 在获取 accept_mutex 锁前，还会根据当前负载来判断是否参与 accept_mutex 锁的争夺。</p>

<p>把这个过程理清了之后，Nginx 解决惊群问题的方法也就出来了，就是利用 accept_mutex 这把锁。</p>

<p>如果配置文件中没有开启 accept_mutex，则所有的监听套接字不管三七二十一，都加入到每子个进程的 epoll中，这样当一个新的连接来到时，所有的 worker 子进程都会惊醒。</p>

<p>如果配置文件中开启了 accept_mutex，则只有一个子进程会将监听套接字添加到 epoll 中，这样当一个新的连接来到时，当然就只有一个 worker 子进程会被唤醒了。</p>

<h2 id="6-小结">6. 小结</h2>

<p>现在我们对惊群及 Nginx 的处理总结如下：</p>

<ul>
<li>accept 不会有惊群，epoll_wait 才会。<br /></li>
<li>Nginx 的 accept_mutex,并不是解决 accept 惊群问题，而是解决 epoll_wait 惊群问题。<br /></li>
<li>说Nginx 解决了 epoll_wait 惊群问题，也是不对的，它只是控制是否将监听套接字加入到epoll 中。监听套接字只在一个子进程的 epoll 中，当新的连接来到时，其他子进程当然不会惊醒了。<br />
<br /></li>
</ul>

<h2 id="7-其他参考文章">7. 其他参考文章</h2>

<p><a href="http://blog.csdn.net/russell_tao/article/details/7204260">“惊群”，看看 nginx 是怎么解决它的</a></p></div>

  </article>
</main>
<footer>
  <div>
    <div>
      2011-2020 strider. <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC-BY-4.0</a></div>
  </div>
</footer>
</body>
</html>
