<!DOCTYPE html>
<html
  lang="zh-cn"
  itemscope
  itemtype="http://schema.org/WebPage"
>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
          Nginx 中的进程间通信 - 纯真年代
        </title>
    

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="strider" />
  <meta name="description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：
套接字（匿名套接字对） 共享内存 信号 本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制 1.1 概述 首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。
" />

  <meta name="keywords" content="程序员, 文学, 生活" />






<meta name="generator" content="Hugo 0.115.1" />


<link rel="canonical" href="https://pureage.info/2015/03/28/ipc-of-nginx.html" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.d8d87b982993a745e5e7b6a6cbf257be8c3e82aab5e485f0908ad7e6c3501ab2.css" integrity="sha256-2Nh7mCmTp0Xl57amy/JXvow&#43;gqq15IXwkIrX5sNQGrI=" media="screen" crossorigin="anonymous">







<meta property="og:title" content="Nginx 中的进程间通信" />
<meta property="og:description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：

套接字（匿名套接字对）
共享内存
信号

本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制
1.1 概述
首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pureage.info/2015/03/28/ipc-of-nginx.html" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2015-03-28T12:39:00+00:00" />
<meta property="article:modified_time" content="2015-03-28T12:39:00+00:00" />
<meta itemprop="name" content="Nginx 中的进程间通信">
<meta itemprop="description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：

套接字（匿名套接字对）
共享内存
信号

本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制
1.1 概述
首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。"><meta itemprop="datePublished" content="2015-03-28T12:39:00+00:00" />
<meta itemprop="dateModified" content="2015-03-28T12:39:00+00:00" />
<meta itemprop="wordCount" content="6817">
<meta itemprop="keywords" content="nginx," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Nginx 中的进程间通信"/>
<meta name="twitter:description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：

套接字（匿名套接字对）
共享内存
信号

本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制
1.1 概述
首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




  </head>
  <body>
    <div id="back-to-top"></div>

    <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">纯真年代</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tools/">工具</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/about/">关于</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/index.xml">订阅</a>
          
        
      </li>
    

    
  </ul>
</nav>


    
      






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

    

    

    


    <header id="header" class="header">
      <div class="logo-wrapper">
  <a href="/" class="logo">
    
      纯真年代
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tools/">工具</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/about/">关于</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/index.xml">订阅</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

    </header>

    <div id="mobile-panel">
      <main id="main" class="main bg-llight wallpaper">
        <div class="content-wrapper">
    <div id="content" class="content">
      <article class="post">
        
        <header class="post-header">
          <h1 class="post-title">Nginx 中的进程间通信</h1>
          

          <div class="post-meta">
  <div class="post-meta-author">
    by
      strider
    
  </div>

  <div class="post-meta-time">
    <time datetime="2015-03-28">
      2015-03-28
    </time>
  </div>

  


  <div class="post-meta__right">
    

    


    
    


    
    
  </div>
</div>

        </header>

        
        <div class="post-content">
          <p>我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：</p>
<ul>
<li>套接字（匿名套接字对）</li>
<li>共享内存</li>
<li>信号</li>
</ul>
<p>本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。</p>
<h2 id="1-nginx-中的-channel-通信机制">1. Nginx 中的 channel 通信机制</h2>
<h3 id="11-概述">1.1 概述</h3>
<p>首先简单的说一下 Nginx 中 channel 通信的机制。</p>
<p>Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。</p>
<p>我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。</p>
<p>那么，当父进程在调用了 socketpair 创建出一对匿名套接字对(A1,B1)后，fork 出一个子进程，那么此时子进程也继承了这一对套接字对(A2,B2)。在这个基础上，父子进程即可进行通信了。例如，父进程对 A1 进行写操作，子进程可通过 B2 进行相应的读操作；子进程对 B2 进行写操作，父进程可以通过 A1 来进行相应的读操作等等。</p>
<p>我们假设，父进程依次 fork 了 N 个子进程，在每次 fork 之前，均如前所述调用了 socketpair 建立起一个匿名套接字对，这样，父进程与各个子进程之间即可通过各自的套接字对来进行通信。</p>
<p>但是各子进程之间能否使用匿名套接字对来进行通信呢？</p>
<p>我们假设父进程 A 中,它与子进程 B 之间的匿名套接字对为 <code>AB[2]</code>，它与子进程 C 之间的匿名套接字对为 <code>AC[2]</code>。且进程 B 在进程 C 之前被 fork 出来。</p>
<p>对进程 B 而言，当它被 fork 出来后，它就继承了父进程创建的套接字对，这里我们将其命名为 <code>BA[2]</code>，这样父进程通过操作 <code>AB[2]</code>，子进程 B 通过操作 <code>BA[2]</code>，即可实现父子进程 A 和 B 之间的通信。</p>
<p>对进程 C 而言，当它被 fork 出来后，他就继承了父进程穿件的套接字对，这里我们将其命名为 <code>CA[2]</code>，这样父进程通过操作 <code>AC[2]</code>，子进程 C 通过操作 <code>CA[2]</code>，即可实现父子进程 A 和 C 之间的通信。</p>
<p>但 B 和 C 有一点不同。由于 B 进程在 C 之前被 fork，B 进程无法从父进程中继承到父进程与 C 进程之间的匿名套接字对，而 C 进程在后面被 fork 出来，它却从父进程处继承到了父进程与子进程 B 之间的匿名套接字对。</p>
<p>这样，之后被 fork 出来的进程 C，可以通过它从父进程那里继承到的与 B 进程相关联的匿名套接字对来向进程 B 发送消息，但进程 B 却无法向进程 C 发送消息。</p>
<p>当子进程数量比较多时，就会造成这样的情况：即后面的进程拥有前面每一个子进程的匿名套接字，但前面的进程则没有后面任何一个子进程的匿名套接字。</p>
<p>那么这个问题该如何解决呢？这就涉及到进程间传递文件描述符这个话题了。可以参考这里：<a href="http://pureage.info/2015/03/19/passing-file-descriptors.html">进程之间传递文件描述符</a>。一个子进程被 fork 出来后，它可以依次向在它之前被 fork 出来的所有子进程传递自己的描述符（匿名套接字对中的一个)。</p>
<p>通过这种机制，子进程之间也可以进行通信了。</p>
<p>Nginx 中也就是这么做的。</p>
<h3 id="12-nginx-中的具体实现">1.2 Nginx 中的具体实现</h3>
<p>在 ngx_process.c 中，定义了一个全局的数组 <code>ngx_processes</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">ngx_process_t</span>    ngx_processes[NGX_MAX_PROCESSES];  
</span></span></code></pre></div><p>其中，<code>ngx_process_t</code> 类型定义为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_pid_t</span>           pid;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>                 status;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_socket_t</span>        channel<span style="color:#960050;background-color:#1e0010">\</span>[<span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">\</span>];  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ngx_spawn_proc_pt   proc;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>               <span style="color:#f92672">*</span>data;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span>               <span style="color:#f92672">*</span>name;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span>            respawn:<span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span>            just_spawn:<span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span>            detached:<span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span>            exiting:<span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span>            exited:<span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">ngx_process_t</span>;  
</span></span></code></pre></div><p>在这里，我们只关心成员 channel 成员，这个两元素的数组即用来存放一个匿名套接字对。</p>
<p>我们假设程序运行后，有 1 个 master 进程和 4 个 worker 进程。那么，对这 5 个进程而言，每个进程都有一个 4 元素的数组 <code>ngx_processes[4]</code>，数组中每个元素都是一个 <code>ngx_process_t</code> 类型的结构体，包含了相应的某个 worker 进程的相关信息。我们这里关心的是每个结构体的 channel 数组成员。</p>
<p>绘制成表如下：
<img src="/img/ipc-4.jpg" alt="ipc-4.jpg"></p>
<p>上表的每一列表示每个进程的 <code>ngx_processes</code> 数组的各个元素的 channel 成员。</p>
<p>其中，master 进程列中的每一个元素，表示master进程与对应的每个 worker 进程之间的匿名套接字对。</p>
<p>而每一个 worker 进程列中的每一个元素，表示该 worker 进程与对应的每个 worker 进程之间的匿名套接字对。当然这只是一个粗略的说法，与真实情况并不完全相符，还有很多细节需要进一步阐述。</p>
<p>我们直接借助《深入剖析 Nginx》，直接看下图的实例：
<img src="/img/ipc-5.jpg" alt="ipc-5.jpg"></p>
<p>再次感谢《深入剖析 Nginx》的作者高群凯，觉得在这里我没法表达的比他更好了。所以下面会引用很多该书中的内容。</p>
<p>在上表中，每一个单元格的内容分别表示 <code>channel[0]</code> 和 <code>channel[1]</code> 的值，-1表示这之前是描述符，但在之后被主动 close() 掉了，0 表示这一直都无对应的描述符，其他数字表示对应的描述符值。</p>
<p>每一列数据都表示该列所对应进程与其他进程进行通信的描述符，如果当前列所对应进程为父进程，那么它与其它进程进行通信的描述符都为 <code>channel[0]</code> (其实 <code>channel[1]</code> 也可以)；如果当前列所对应的进程为子进程，那么它与父进程进行通信的描述符为 <code>channel[1]</code>（注：这里书中说的太简略，应该为如果当前列所对应的进程为子进程，那么它与父进程进行通信的描述符为该进程的 ngx_processes 数组中，与本进程对应的元素中的 <code>channel[1]</code>，在图中即为标粗的对角线部分，即 <code>[-1,7]</code>，<code>[-1,9]</code>，<code>[-1,11]</code>，<code>[-1,13]</code>这四对），与其它子进程进行通信的描述符都为本进程的 <code>ngx_processes</code> 数组中与该其它进程对应元素的 <code>channel[0]</code>。</p>
<p>比如，<code>[3，7]</code> 单元格表示，如果父进程向 worker0 发送消息，需要使用 <code>channel[0]</code>，即描述符 3，实际上 <code>channel[1]</code> 也可以，它的 <code>channel[1]</code> 为 7，没有被 close() 关闭掉，但一直也没有被使用，所以没有影响，不过按道理应该关闭才是。</p>
<p>再比如，<code>[-1，7]</code> 单元格表示如果 worker0 向 master 进程发送消息，需要使用 <code>channel[1]</code>，即描述符 7，它的 <code>channel[0]</code> 为 -1，表示已经 close() 关闭掉了（Nginx某些地方调用 close() 时并没有设置对应变量为 -1，这里只是为了更好的说明，将已经 close() 掉的描述符全部标记为 -1）。</p>
<p>越是后生成的 worker 进程，其 <code>ngx_processes</code> 数组的元素中，<code>channel[0]</code> 与父进程对应的 <code>ngx_processes</code> 数组的元素中的 <code>channel[0]</code> 值相同的越多，因为基本都是继承而来，但前面生成的 worker 进程，其 <code>channel[0]</code> 是通过进程间调用 sendmsg 传递获得的，所以与父进程对应的 <code>channel[0]</code> 不一定相等。比如，如果 worker0 向 worker3 发送消息，需要使用worker0 进程的 <code>ngx_processes[3]</code> 元素的 <code>channel[0]</code>，即描述符 10，而对应 master 进程的 <code>ngx_processes[3]</code> 元素的 <code>channel[0]</code> 却是 12。虽然它们在各自进程里表现为不同的整型数字，但在内核里表示同一个描述符结构，即不管是 worker0 往描述符 10 写数据，还是master 往描述符 12 写数据，worker3 都能通过描述符 13 正确读取到这些数据，至于 worker3 怎么识别它读到的数据是来自 worker0，还是 master，就得靠其他收到的数据特征，比如pid，来做标记区分。</p>
<p>关于上段讲的，一个子进程如何区分接收到的数据是来自哪一个进程，我们可以看一下 Nginx-1.6.2中的一段代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">ngx_int_t</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_write_channel</span>(<span style="color:#66d9ef">ngx_socket_t</span> s, <span style="color:#66d9ef">ngx_channel_t</span> <span style="color:#f92672">*</span>ch, <span style="color:#66d9ef">size_t</span> size,  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_log_t</span> <span style="color:#f92672">*</span>log)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ssize_t</span>             n;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_err_t</span>           err;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> iovec        iov[<span style="color:#ae81ff">1</span>];  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> msghdr       msg;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if (NGX_HAVE_MSGHDR_MSG_CONTROL)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> cmsghdr  cm;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span>            space[<span style="color:#a6e22e">CMSG_SPACE</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>))];  
</span></span><span style="display:flex;"><span>    } cmsg;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ch<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        msg.msg_control <span style="color:#f92672">=</span> NULL;  
</span></span><span style="display:flex;"><span>        msg.msg_controllen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        msg.msg_control <span style="color:#f92672">=</span> (<span style="color:#66d9ef">caddr_t</span>) <span style="color:#f92672">&amp;</span>cmsg;  
</span></span><span style="display:flex;"><span>        msg.msg_controllen <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(cmsg);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_memzero</span>(<span style="color:#f92672">&amp;</span>cmsg, <span style="color:#66d9ef">sizeof</span>(cmsg));  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        cmsg.cm.cmsg_len <span style="color:#f92672">=</span> <span style="color:#a6e22e">CMSG_LEN</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));  
</span></span><span style="display:flex;"><span>        cmsg.cm.cmsg_level <span style="color:#f92672">=</span> SOL_SOCKET;  
</span></span><span style="display:flex;"><span>        cmsg.cm.cmsg_type <span style="color:#f92672">=</span> SCM_RIGHTS;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * We have to use ngx_memcpy() instead of simple  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *   *(int *) CMSG_DATA(&amp;cmsg.cm) = ch-&gt;fd;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * because some gcc 4.4 with -O2/3/s optimization issues the warning:  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *   dereferencing type-punned pointer will break strict-aliasing rules  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Fortunately, gcc with -O1 compiles this ngx_memcpy()  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * in the same simple assignment as in the code above  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_memcpy</span>(<span style="color:#a6e22e">CMSG_DATA</span>(<span style="color:#f92672">&amp;</span>cmsg.cm), <span style="color:#f92672">&amp;</span>ch<span style="color:#f92672">-&gt;</span>fd, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    msg.msg_flags <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ch<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        msg.msg_accrights <span style="color:#f92672">=</span> NULL;  
</span></span><span style="display:flex;"><span>        msg.msg_accrightslen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        msg.msg_accrights <span style="color:#f92672">=</span> (<span style="color:#66d9ef">caddr_t</span>) <span style="color:#f92672">&amp;</span>ch<span style="color:#f92672">-&gt;</span>fd;  
</span></span><span style="display:flex;"><span>        msg.msg_accrightslen <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>    iov[<span style="color:#ae81ff">0</span>].iov_base <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) ch;  
</span></span><span style="display:flex;"><span>    iov[<span style="color:#ae81ff">0</span>].iov_len <span style="color:#f92672">=</span> size;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    msg.msg_name <span style="color:#f92672">=</span> NULL;  
</span></span><span style="display:flex;"><span>    msg.msg_namelen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>    msg.msg_iov <span style="color:#f92672">=</span> iov;  
</span></span><span style="display:flex;"><span>    msg.msg_iovlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#a6e22e">sendmsg</span>(s, <span style="color:#f92672">&amp;</span>msg, <span style="color:#ae81ff">0</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        err <span style="color:#f92672">=</span> ngx_errno;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (err <span style="color:#f92672">==</span> NGX_EAGAIN) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NGX_AGAIN;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, log, err, <span style="color:#e6db74">&#34;sendmsg() failed&#34;</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NGX_ERROR;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NGX_OK;  
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>在调用时，参数 ch 即为发送的数据部分，其类型定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_uint_t</span>  command;  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_pid_t</span>   pid;  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_int_t</span>   slot;  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_fd_t</span>    fd;  
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">ngx_channel_t</span>;  
</span></span></code></pre></div><p>可见，其中就包含了发送方的pid。</p>
<p>最后，就目前 Nginx 代码来看，子进程并没有往父进程发送任何消息，子进程之间也没有相互通信的逻辑。也许是因为 Nginx 有其他一些更好的进程通信方式，比如共享内存等，所以这种 channel 通信目前仅作为父进程往子进程发送消息使用。但由于有这个架构在，可以很轻松使用 channel 机制来完成各进程间的通信任务。</p>
<h3 id="13-nginx-中的相关代码流程">1.3 Nginx 中的相关代码流程</h3>
<p>下面，将上面所讲的内容，在 Nginx 代码中的流程，大概梳理一遍。本文所有代码片段，均来自于nginx-1.6.2。</p>
<p>首先是 main 函数调用 <code>ngx_master_process_cycle</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ngx_process <span style="color:#f92672">==</span> NGX_PROCESS_SINGLE) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_single_process_cycle</span>(cycle);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_master_process_cycle</span>(cycle);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  
</span></span></code></pre></div><p>ngx_master_process_cycle<code>调用</code>ngx_start_worker_processes`：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ccf <span style="color:#f92672">=</span> (<span style="color:#66d9ef">ngx_core_conf_t</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">ngx_get_conf</span>(cycle<span style="color:#f92672">-&gt;</span>conf_ctx, ngx_core_module);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_start_worker_processes</span>(cycle, ccf<span style="color:#f92672">-&gt;</span>worker_processes,  
</span></span><span style="display:flex;"><span>                           NGX_PROCESS_RESPAWN);  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_start_cache_manager_processes</span>(cycle, <span style="color:#ae81ff">0</span>);  
</span></span></code></pre></div><p>在 <code>ngx_start_worker_processes</code> 函数中，完成对所有 worker 进程的 fork 操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_start_worker_processes</span>(<span style="color:#66d9ef">ngx_cycle_t</span> <span style="color:#f92672">*</span>cycle, <span style="color:#66d9ef">ngx_int_t</span> n, <span style="color:#66d9ef">ngx_int_t</span> type)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_int_t</span>      i;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_channel_t</span>  ch;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_NOTICE, cycle<span style="color:#f92672">-&gt;</span>log, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;start worker processes&#34;</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ngx_memzero</span>(<span style="color:#f92672">&amp;</span>ch, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">ngx_channel_t</span>));  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    ch.command <span style="color:#f92672">=</span> NGX_CMD_OPEN_CHANNEL;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_spawn_process</span>(cycle, ngx_worker_process_cycle,  
</span></span><span style="display:flex;"><span>                          (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) (<span style="color:#66d9ef">intptr_t</span>) i, <span style="color:#e6db74">&#34;worker process&#34;</span>, type);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        ch.pid <span style="color:#f92672">=</span> ngx_processes[ngx_process_slot].pid;  
</span></span><span style="display:flex;"><span>        ch.slot <span style="color:#f92672">=</span> ngx_process_slot;  
</span></span><span style="display:flex;"><span>        ch.fd <span style="color:#f92672">=</span> ngx_processes[ngx_process_slot].channel[<span style="color:#ae81ff">0</span>];  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_pass_open_channel</span>(cycle, <span style="color:#f92672">&amp;</span>ch);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>上述代码调用的 <code>ngx_spawn_process</code> 即完成具体的 <code>socketpair()</code> 操作和 fork 操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">ngx_pid_t</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_spawn_process</span>(<span style="color:#66d9ef">ngx_cycle_t</span> <span style="color:#f92672">*</span>cycle, ngx_spawn_proc_pt proc, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data,  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">ngx_int_t</span> respawn)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>       ......  
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">socketpair</span>(AF_UNIX, SOCK_STREAM, <span style="color:#ae81ff">0</span>, ngx_processes[s].channel) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>        {  
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, cycle<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                          <span style="color:#e6db74">&#34;socketpair() failed while spawning </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>, name);  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NGX_INVALID_PID;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>        ......  
</span></span><span style="display:flex;"><span>        ngx_channel <span style="color:#f92672">=</span> ngx_processes[s].channel[<span style="color:#ae81ff">1</span>];  
</span></span><span style="display:flex;"><span>        ......  
</span></span><span style="display:flex;"><span>        ngx_process_slot <span style="color:#f92672">=</span> s;  
</span></span><span style="display:flex;"><span>        pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>();  
</span></span><span style="display:flex;"><span>        ......  
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>在上一段代码中可以看到，master 进程在调用 socketpair 后，将生成的 <code>channel[1]</code> 保存在全局变量 <code>ngx_channel</code> 中，<code>ngx_channel</code> 全局变量的作用是，子进程中会使用该全局变量，并加入到自己的事件集中，达到的效果即是子进程将 <code>channel[1]</code> 加入到自己的事件集中。</p>
<p>话分两头，我们先来具体看看子进程的流程。</p>
<p>在主进程执行完 fork 之后，<code>ngx_start_worker_processes</code> 会调用 proc 回调：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>   pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>();  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (pid) {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, cycle<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;fork() failed while spawning </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>, name);  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_close_channel</span>(ngx_processes[s].channel, cycle<span style="color:#f92672">-&gt;</span>log);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NGX_INVALID_PID;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>        ngx_pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">ngx_getpid</span>();  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">proc</span>(cycle, data);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span></code></pre></div><p>其中，proc 即为 <code>ngx_worker_process_cycle</code>。<code>ngx_worker_process_cycle</code> 会调用<code>ngx_worker_process_init</code> 函数，子进程将从父进程处继承到的 <code>channel[1]</code> 加入到自己的事件集中，就是在这个函数中完成的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_worker_process_init</span>(<span style="color:#66d9ef">ngx_cycle_t</span> <span style="color:#f92672">*</span>cycle, <span style="color:#66d9ef">ngx_int_t</span> worker)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>......  
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> (n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; n <span style="color:#f92672">&lt;</span> ngx_last_process; n<span style="color:#f92672">++</span>) {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ngx_processes[n].pid <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> ngx_process_slot) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ngx_processes[n].channel[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">close</span>(ngx_processes[n].channel[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, cycle<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                          <span style="color:#e6db74">&#34;close() channel failed&#34;</span>);  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">close</span>(ngx_processes[ngx_process_slot].channel[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, cycle<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;close() channel failed&#34;</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if 0</span><span style="color:#75715e">  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    ngx_last_process = 0;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ngx_add_channel_event</span>(cycle, ngx_channel, NGX_READ_EVENT,  
</span></span><span style="display:flex;"><span>                              ngx_channel_handler)  
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">==</span> NGX_ERROR)  
</span></span><span style="display:flex;"><span>    {  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* fatal */</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">2</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>......  
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>具体的将 <code>channel[1]</code> 添加到事件集中的操作，是由 <code>ngx_add_channel_event</code> 来完成的，对应的回调处理函数为 <code>ngx_channel_handler</code>，同时我们看到，在添加之前，还进行了很多 close 的工作，这就于之前的示例表里，那些描述符为 -1 的表项相对应了。</p>
<p>此时，子进程已经将从父进程那里继承来的 <code>channel[1]</code> 加入到了自己的监听事件集中，这样，一个子进程从自己的 <code>ngx_processses</code> 数组中，对应本进程的那一个元素中的 <code>channel[1]</code> 中，即可读取来自其他进程的消息。收到消息时，将执行设置好的回调函数<code>ngx_channel_handler</code>，把接收到的新子进程的相关信息存储在自己的全局变量<code>ngx_processes</code> 数组内。见下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_channel_handler</span>(<span style="color:#66d9ef">ngx_event_t</span> <span style="color:#f92672">*</span>ev)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    ......  
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> NGX_CMD_OPEN_CHANNEL:  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ngx_log_debug3</span>(NGX_LOG_DEBUG_CORE, ev<span style="color:#f92672">-&gt;</span>log, <span style="color:#ae81ff">0</span>,  
</span></span><span style="display:flex;"><span>                           <span style="color:#e6db74">&#34;get channel s:%i pid:%P fd:%d&#34;</span>,  
</span></span><span style="display:flex;"><span>                           ch.slot, ch.pid, ch.fd);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>            ngx_processes[ch.slot].pid <span style="color:#f92672">=</span> ch.pid;  
</span></span><span style="display:flex;"><span>            ngx_processes[ch.slot].channel[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> ch.fd;  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;  
</span></span><span style="display:flex;"><span>    ......  
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>我们再回到父进程中。</p>
<p>父进程在从 <code>ngx_spawn_process</code> 返回后，回来继续执行 <code>ngx_start_worker_processes</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_start_worker_processes</span>(<span style="color:#66d9ef">ngx_cycle_t</span> <span style="color:#f92672">*</span>cycle, <span style="color:#66d9ef">ngx_int_t</span> n, <span style="color:#66d9ef">ngx_int_t</span> type)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_int_t</span>      i;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_channel_t</span>  ch;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_NOTICE, cycle<span style="color:#f92672">-&gt;</span>log, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;start worker processes&#34;</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ngx_memzero</span>(<span style="color:#f92672">&amp;</span>ch, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">ngx_channel_t</span>));  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    ch.command <span style="color:#f92672">=</span> NGX_CMD_OPEN_CHANNEL;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_spawn_process</span>(cycle, ngx_worker_process_cycle,  
</span></span><span style="display:flex;"><span>                          (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) (<span style="color:#66d9ef">intptr_t</span>) i, <span style="color:#e6db74">&#34;worker process&#34;</span>, type);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        ch.pid <span style="color:#f92672">=</span> ngx_processes[ngx_process_slot].pid;  
</span></span><span style="display:flex;"><span>        ch.slot <span style="color:#f92672">=</span> ngx_process_slot;  
</span></span><span style="display:flex;"><span>        ch.fd <span style="color:#f92672">=</span> ngx_processes[ngx_process_slot].channel[<span style="color:#ae81ff">0</span>];  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_pass_open_channel</span>(cycle, <span style="color:#f92672">&amp;</span>ch);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>其中的 for 循环即表示，父进程会把刚刚生成的子进程的 <code>channel[0]</code>，放在一条<strong>消息</strong>的内容中发送给之前生成的子进程。<strong>消息</strong>的格式定义为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_uint_t</span>  command;  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_pid_t</span>   pid;  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_int_t</span>   slot;  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">ngx_fd_t</span>    fd;  
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">ngx_channel_t</span>;  
</span></span></code></pre></div><p>我们看下 <code>ngx_pass_open_channel</code> 函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_pass_open_channel</span>(<span style="color:#66d9ef">ngx_cycle_t</span> <span style="color:#f92672">*</span>cycle, <span style="color:#66d9ef">ngx_channel_t</span> <span style="color:#f92672">*</span>ch)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_int_t</span>  i;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ngx_last_process; i<span style="color:#f92672">++</span>) {  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> ngx_process_slot  
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">||</span> ngx_processes[i].pid <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">||</span> ngx_processes[i].channel[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>        {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_debug6</span>(NGX_LOG_DEBUG_CORE, cycle<span style="color:#f92672">-&gt;</span>log, <span style="color:#ae81ff">0</span>,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;pass channel s:%d pid:%P fd:%d to s:%i pid:%P fd:%d&#34;</span>,  
</span></span><span style="display:flex;"><span>                      ch<span style="color:#f92672">-&gt;</span>slot, ch<span style="color:#f92672">-&gt;</span>pid, ch<span style="color:#f92672">-&gt;</span>fd,  
</span></span><span style="display:flex;"><span>                      i, ngx_processes[i].pid,  
</span></span><span style="display:flex;"><span>                      ngx_processes[i].channel[<span style="color:#ae81ff">0</span>]);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* TODO: NGX_AGAIN */</span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_write_channel</span>(ngx_processes[i].channel[<span style="color:#ae81ff">0</span>],  
</span></span><span style="display:flex;"><span>                          ch, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">ngx_channel_t</span>), cycle<span style="color:#f92672">-&gt;</span>log);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>从该函数定义中，可以很清晰的看到“往之前生成的每个进程发送消息”。对之前的每个子进程，具体消息发送工作，是由函数 <code>ngx_write_channel</code> 完成的。</p>
<p><code>ngx_write_channel</code> 函数的第一个参数是之前某个进程从 master 进程继承来的 <code>channel[0]</code>，第二个参数是发送的内容。其中包含了当前进程的 pid、slot号、command 等信息，最重要的是，包含了当前子进程的 <code>channel[0]</code>，其实是实现了一个简单的协议。注意，当前子进程的 <code>channel[0]</code> 虽然存在 <code>ngx_channel_t</code> 类型的消息体中，但真正文件描述符的传递操作，是 <code>ngx_write_channel</code> 通过发送控制信息来完成的。接收进程虽然在接收到的消息体中获得了发送进程的 <code>channel[0]</code> 这个值，但并不能直接使用，必须根据控制信息来获取一个新的文件描述符。参看<a href="jin_cheng_jian_chuan_di_wen_jian_miao_shu_fu.md">进程间传递文件描述符</a>。</p>
<p>至此，父子进程间的配合，使得所有的子进程均拥有了其他子进程的 <code>channel[0]</code>，而另一方面，由于所有子进程的 <code>channel[1]</code> 已加入到自己的监听事件集，所以子进程之间的通信通道即被建立起来。</p>
<p>值得一提的是，父进程在调用 socketpair() 产生一个匿名套接字对后，再 fork 出一个子进程，那么现在有 4 个文件描述符了。其实对这 4 个文件描述符中的任何一个进行写入，从其他3个描述符中的任何一个均可以进行读取操作。</p>
<p>但 Nginx 通过一些 close() 操作，有意达到这样一种目的：</p>
<ul>
<li>对任何一个子进程，其 <code>ngx_processes</code> 数组中，对应其它进程的元素，其 <code>channel[0]</code> 用来向“该其他进程”发送消息。</li>
<li>对任何一个子进程，其 <code>ngx_processes</code> 数组中，对应本进程的元素，其 <code>channel[1]</code> 用来接收来自其他进程的消息，这个其他进程既包括其他子进程，也包括 master 进程。至于如何区分是来自哪个进程，以及该消息是用来做什么的，则通过判断 ngx_channel_t 类型的消息的comman、pid、slot等成员来协商。</li>
<li>对 master 进程，其 <code>ngx_processes</code> 数组的中，对应相应子进程的元素的 <code>channel[0]</code>，用来向该子进程发送消息。注:其实 <code>channel[1]</code> 也可以，但按常理，master 进程的 <code>ngx_processes</code> 数组所有元素的 <code>channel[1]</code> 应该关闭的。</li>
</ul>
<h2 id="2-nginx-中的共享内存">2. Nginx 中的共享内存</h2>
<h3 id="21-概述">2.1 概述</h3>
<blockquote>
<p>共享内存是 Linux 下提供的最基本的进程间通信方法，它通过 mmap 或者 shmget 系统调用在内存中创建了一块连续的线性地址空间，而通过 munmap 或者 shmdt 系统调用可以释放这块内存。使用共享内存的好处是当多个进程使用同一块共享内存时，在任何一个进程修改了共享内存中的内容后，其他进程通过访问这段共享内存都能够得到修改后的内容。</p>
<p>陶辉《深入理解Nginx》</p>
</blockquote>
<p>共享内存可以说是最有用的进程间通信方式，也是最快的 IPC 形式。两个不同进程 A、B 共享内存的意思是，同一块物理内存被映射到进程 A、B 各自的进程地址空间。进程 A 可以即时看到进程 B 对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</p>
<p>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>Linux 中，共享内存可以通过两个系统系统调用来获得，mmap 和shmget，分别属于不同的标准，这不在本文的关注范围之内。mmap 语义上比 shmget 更通用，因为它最一般的做法，是将一个打开的实体文件，映射到一段连续的内存中，各个进程可以根据各自的权限对该段内存进行相应的读写操作，其他进程则可以看到其他进程写入的结果。而 shmget 在语义上相当于是匿名的 mmap，即不关注实体文件，直接在内存中开辟这块共享区域，mmap 通过设置调用时的参数，也可达到这种效果，一种方法是映射 /dev/zero 设备,另一种是使用 MAP_ANON选 项。至于 mmap 和 shmget 的效率，跟不同的内核实现相关，不在本文关注范围内。</p>
<p>除了上面的简单描述外，本文不打算仔细介绍 mmap 和 shmget 的使用。有如下相关资料可以参考：</p>
<ol>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html">Linux环境进程间通信（五）: 共享内存（上）</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html">Linux环境进程间通信（五）: 共享内存（下）</a></li>
<li>APUE,14.8,15.9</li>
</ol>
<h3 id="22-nginx-中的实现">2.2 Nginx 中的实现</h3>
<p>那么，在 Nginx 中，到底是选用 mmap 映射到 /dev/null，还是使用 MAP_ANON 选项调用mmap，或者是使用 shmget 呢？看相关实现的代码就会一目了然：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Copyright (C) Igor Sysoev  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Copyright (C) Nginx, Inc.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ngx_config.h&gt;  </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ngx_core.h&gt;  </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if (NGX_HAVE_MAP_ANON)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ngx_int_t</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_shm_alloc</span>(<span style="color:#66d9ef">ngx_shm_t</span> <span style="color:#f92672">*</span>shm)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> (u_char <span style="color:#f92672">*</span>) <span style="color:#a6e22e">mmap</span>(NULL, shm<span style="color:#f92672">-&gt;</span>size,  
</span></span><span style="display:flex;"><span>                                PROT_READ<span style="color:#f92672">|</span>PROT_WRITE,  
</span></span><span style="display:flex;"><span>                                MAP_ANON<span style="color:#f92672">|</span>MAP_SHARED, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">==</span> MAP_FAILED) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;mmap(MAP_ANON|MAP_SHARED, %uz) failed&#34;</span>, shm<span style="color:#f92672">-&gt;</span>size);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NGX_ERROR;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NGX_OK;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_shm_free</span>(<span style="color:#66d9ef">ngx_shm_t</span> <span style="color:#f92672">*</span>shm)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">munmap</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) shm<span style="color:#f92672">-&gt;</span>addr, shm<span style="color:#f92672">-&gt;</span>size) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;munmap(%p, %uz) failed&#34;</span>, shm<span style="color:#f92672">-&gt;</span>addr, shm<span style="color:#f92672">-&gt;</span>size);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif (NGX_HAVE_MAP_DEVZERO)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ngx_int_t</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_shm_alloc</span>(<span style="color:#66d9ef">ngx_shm_t</span> <span style="color:#f92672">*</span>shm)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ngx_fd_t</span>  fd;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;/dev/zero&#34;</span>, O_RDWR);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;open(</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">/dev/zero</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">) failed&#34;</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NGX_ERROR;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> (u_char <span style="color:#f92672">*</span>) <span style="color:#a6e22e">mmap</span>(NULL, shm<span style="color:#f92672">-&gt;</span>size, PROT_READ<span style="color:#f92672">|</span>PROT_WRITE,  
</span></span><span style="display:flex;"><span>                                MAP_SHARED, fd, <span style="color:#ae81ff">0</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">==</span> MAP_FAILED) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;mmap(/dev/zero, MAP_SHARED, %uz) failed&#34;</span>, shm<span style="color:#f92672">-&gt;</span>size);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">close</span>(fd) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;close(</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">/dev/zero</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">) failed&#34;</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">==</span> MAP_FAILED) <span style="color:#f92672">?</span> NGX_ERROR : NGX_OK;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_shm_free</span>(<span style="color:#66d9ef">ngx_shm_t</span> <span style="color:#f92672">*</span>shm)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">munmap</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) shm<span style="color:#f92672">-&gt;</span>addr, shm<span style="color:#f92672">-&gt;</span>size) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;munmap(%p, %uz) failed&#34;</span>, shm<span style="color:#f92672">-&gt;</span>addr, shm<span style="color:#f92672">-&gt;</span>size);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif (NGX_HAVE_SYSVSHM)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ipc.h&gt;  </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/shm.h&gt;  </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ngx_int_t</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_shm_alloc</span>(<span style="color:#66d9ef">ngx_shm_t</span> <span style="color:#f92672">*</span>shm)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>  id;  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    id <span style="color:#f92672">=</span> <span style="color:#a6e22e">shmget</span>(IPC_PRIVATE, shm<span style="color:#f92672">-&gt;</span>size, (SHM_R<span style="color:#f92672">|</span>SHM_W<span style="color:#f92672">|</span>IPC_CREAT));  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (id <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;shmget(%uz) failed&#34;</span>, shm<span style="color:#f92672">-&gt;</span>size);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NGX_ERROR;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ngx_log_debug1</span>(NGX_LOG_DEBUG_CORE, shm<span style="color:#f92672">-&gt;</span>log, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;shmget id: %d&#34;</span>, id);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">shmat</span>(id, NULL, <span style="color:#ae81ff">0</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">==</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno, <span style="color:#e6db74">&#34;shmat() failed&#34;</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">shmctl</span>(id, IPC_RMID, NULL) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;shmctl(IPC_RMID) failed&#34;</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (shm<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">==</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> NGX_ERROR : NGX_OK;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ngx_shm_free</span>(<span style="color:#66d9ef">ngx_shm_t</span> <span style="color:#f92672">*</span>shm)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">shmdt</span>(shm<span style="color:#f92672">-&gt;</span>addr) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ngx_log_error</span>(NGX_LOG_ALERT, shm<span style="color:#f92672">-&gt;</span>log, ngx_errno,  
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;shmdt(%p) failed&#34;</span>, shm<span style="color:#f92672">-&gt;</span>addr);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  
</span></span></span></code></pre></div><p>上面的代码即是 Nginx 源代码中的 src/os/unix/ngx_shemem.c 的全部内容。可见，整个文件只是为了提供两个接口：ngx_shm_alloc 和ngx_shm_free。而这两个接口的实现，按如下逻辑来决定：</p>
<ol>
<li>如果当前系统的 mmap 系统调用支持 MAP_ANON 选项，则使用带 MAP_ANON 选项的mmap。</li>
<li>如果 1 不满足，则如果当前系统 mmap 系统调用支持映射 /dev/zero 设备，则使用 mmap 映射 /dev/zero 的方式来实现。</li>
<li>如果上面 1 和 2 都不满足，且如果当前系统支持 shmget 系统调用的话，则使用该系统调用来实现。</li>
</ol>
<p>看到这里，也许大家就有疑问了，如果当前 3 个条件都不满足怎么办，那就没辙了，<code>ngx_shm_alloc</code> 接口没有相应的定义，只能在链接的时候就不成功了。</p>
<p>另外，关于上面三种情况的判断，都是通过相应的宏是否定义来进行的，而相应的宏的定义，是在auto/unix 脚本中进行的，该脚本会写一端测试程序来判断相应的系统调用是否支持，如果支持，则在 configure 后自动生成的 objs/ngx_auto_config.h 文件中定义对应的宏。</p>
<h2 id="3-channel-机制和共享内存在-nginx-中的使用情况">3. channel 机制和共享内存在 Nginx 中的使用情况</h2>
<p>前面讲 Nginx 中的 channel 机制时提到，Nginx 虽然提供了这种机制，但目前很少用到，而共享内存却相对用的比较多了。例如，为了统计 Nginx 总体的 http 请求处理情况，需要跨越多个 worker 来计算，Nginx 自带的 http 模块 ngx_http_stub_status_module 即主要依赖共享内存的方式。</p>
        </div>

        
        
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">strider</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2015-03-28
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>



        
        


        <footer class="post-footer">
          <div class="post-tags">
              <a href="https://pureage.info/tags/nginx/">nginx</a>
                
            </div>


          
          <nav class="post-nav">
            
              <a class="prev" href="/2015/06/25/nginx-proxy-cache-and-etag.html">
                
                <i class="iconfont">
                  <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

                </i>
                <span class="prev-text nav-default">nginx proxy_cache 与 etag 配合的问题</span>
                <span class="prev-text nav-mobile">上一篇</span>
              </a>
            
              <a class="next" href="/2015/03/19/passing-file-descriptors.html">
                <span class="next-text nav-default">进程间传递文件描述符</span>
                <span class="prev-text nav-mobile">下一篇</span>
                
                <i class="iconfont">
                  <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

                </i>
              </a>
          </nav>
        </footer>
      </article>

      
      


      
      

  

  
  

  
  

  

  

    

  

  


    </div>

    
    


  </div>

      </main>

      <footer id="footer" class="footer">
        <div class="icon-links">
  


<a href="https://pureage.info/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2011 -
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        strider
        
      </span></span>

  
  

  
</div>

      </footer>

      <div class="button__back-to-top">
        <a href="#back-to-top">
          <i class="iconfont">
            
            <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

          </i>
        </a>
      </div>
    </div>
    
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.419d62fdd33d03e55ca7c874a720b9a5d8bc25d215992621f18eb9f8dad9ac3c.js" integrity="sha256-QZ1i/dM9A&#43;Vcp8h0pyC5pdi8JdIVmSYh8Y65&#43;NrZrDw=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  

















  </body>
</html>
