<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="strider (方鹏)">
<meta name="description" content="一个伪文青兼程序员的自嗨
    ">
<meta name="keywords" content="博客, 技术, 文学, 电影">
<meta name="referrer" content="always">
<title>Nginx 中的进程间通信 - 纯真年代</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://pureage.info/">纯真年代</a></h1><h2><a href="https://pureage.info/">阅读、体验、沉淀...</a></h2>
  </div>
  <nav><a href="/">博客</a><a href="/tools/">工具</a><a href="/about/">关于</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>Nginx 中的进程间通信</h1>
  </div>
<div class="meta">
  <div>2015-03-28</div>
  <div>
    <span><a href="/tags/nginx">#nginx</a></span>
    </div>
  </div>
<div class="content">
  <p>我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：</p>
<ul>
<li>套接字（匿名套接字对）</li>
<li>共享内存</li>
<li>信号</li>
</ul>
<p>本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。</p>
<h2 id="1-nginx-中的-channel-通信机制">1. Nginx 中的 channel 通信机制</h2>
<h3 id="11-概述">1.1 概述</h3>
<p>首先简单的说一下 Nginx 中 channel 通信的机制。</p>
<p>Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。</p>
<p>我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。</p>
<p>那么，当父进程在调用了 socketpair 创建出一对匿名套接字对(A1,B1)后，fork 出一个子进程，那么此时子进程也继承了这一对套接字对(A2,B2)。在这个基础上，父子进程即可进行通信了。例如，父进程对 A1 进行写操作，子进程可通过 B2 进行相应的读操作；子进程对 B2 进行写操作，父进程可以通过 A1 来进行相应的读操作等等。</p>
<p>我们假设，父进程依次 fork 了 N 个子进程，在每次 fork 之前，均如前所述调用了 socketpair 建立起一个匿名套接字对，这样，父进程与各个子进程之间即可通过各自的套接字对来进行通信。</p>
<p>但是各子进程之间能否使用匿名套接字对来进行通信呢？</p>
<p>我们假设父进程 A 中,它与子进程 B 之间的匿名套接字对为 <code>AB[2]</code>，它与子进程 C 之间的匿名套接字对为 <code>AC[2]</code>。且进程 B 在进程 C 之前被 fork 出来。</p>
<p>对进程 B 而言，当它被 fork 出来后，它就继承了父进程创建的套接字对，这里我们将其命名为 <code>BA[2]</code>，这样父进程通过操作 <code>AB[2]</code>，子进程 B 通过操作 <code>BA[2]</code>，即可实现父子进程 A 和 B 之间的通信。</p>
<p>对进程 C 而言，当它被 fork 出来后，他就继承了父进程穿件的套接字对，这里我们将其命名为 <code>CA[2]</code>，这样父进程通过操作 <code>AC[2]</code>，子进程 C 通过操作 <code>CA[2]</code>，即可实现父子进程 A 和 C 之间的通信。</p>
<p>但 B 和 C 有一点不同。由于 B 进程在 C 之前被 fork，B 进程无法从父进程中继承到父进程与 C 进程之间的匿名套接字对，而 C 进程在后面被 fork 出来，它却从父进程处继承到了父进程与子进程 B 之间的匿名套接字对。</p>
<p>这样，之后被 fork 出来的进程 C，可以通过它从父进程那里继承到的与 B 进程相关联的匿名套接字对来向进程 B 发送消息，但进程 B 却无法向进程 C 发送消息。</p>
<p>当子进程数量比较多时，就会造成这样的情况：即后面的进程拥有前面每一个子进程的匿名套接字，但前面的进程则没有后面任何一个子进程的匿名套接字。</p>
<p>那么这个问题该如何解决呢？这就涉及到进程间传递文件描述符这个话题了。可以参考这里：<a href="http://pureage.info/2015/03/19/passing-file-descriptors.html">进程之间传递文件描述符</a>。一个子进程被 fork 出来后，它可以依次向在它之前被 fork 出来的所有子进程传递自己的描述符（匿名套接字对中的一个)。</p>
<p>通过这种机制，子进程之间也可以进行通信了。</p>
<p>Nginx 中也就是这么做的。</p>
<h3 id="12-nginx-中的具体实现">1.2 Nginx 中的具体实现</h3>
<p>在 ngx_process.c 中，定义了一个全局的数组 <code>ngx_processes</code>：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000">ngx_process_t</span>    <span style="color:#000">ngx_processes</span>[<span style="color:#000">NGX_MAX_PROCESSES</span>];  
</code></pre></div><p>其中，<code>ngx_process_t</code> 类型定义为：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> {
    <span style="color:#000">ngx_pid_t</span>           <span style="color:#000">pid</span>;  
    <span style="color:#00f">int</span>                 <span style="color:#000">status</span>;  
    <span style="color:#000">ngx_socket_t</span>        <span style="color:#000">channel</span><span style="color:#f00">\</span>[<span style="color:#3af">2</span><span style="color:#f00">\</span>];  

    <span style="color:#000">ngx_spawn_proc_pt</span>   <span style="color:#000">proc</span>;  
    <span style="color:#00f">void</span>               *<span style="color:#000">data</span>;  
    <span style="color:#00f">char</span>               *<span style="color:#000">name</span>;  
  
    <span style="color:#00f">unsigned</span>            <span style="color:#000">respawn</span>:<span style="color:#3af">1</span>;  
    <span style="color:#00f">unsigned</span>            <span style="color:#000">just_spawn</span>:<span style="color:#3af">1</span>;  
    <span style="color:#00f">unsigned</span>            <span style="color:#000">detached</span>:<span style="color:#3af">1</span>;  
    <span style="color:#00f">unsigned</span>            <span style="color:#000">exiting</span>:<span style="color:#3af">1</span>;  
    <span style="color:#00f">unsigned</span>            <span style="color:#000">exited</span>:<span style="color:#3af">1</span>;  
} <span style="color:#000">ngx_process_t</span>;  
</code></pre></div><p>在这里，我们只关心成员 channel 成员，这个两元素的数组即用来存放一个匿名套接字对。</p>
<p>我们假设程序运行后，有 1 个 master 进程和 4 个 worker 进程。那么，对这 5 个进程而言，每个进程都有一个 4 元素的数组 <code>ngx_processes[4]</code>，数组中每个元素都是一个 <code>ngx_process_t</code> 类型的结构体，包含了相应的某个 worker 进程的相关信息。我们这里关心的是每个结构体的 channel 数组成员。</p>
<p>绘制成表如下：
<img src="/img/ipc-4.jpg" alt="ipc-4.jpg"></p>
<p>上表的每一列表示每个进程的 <code>ngx_processes</code> 数组的各个元素的 channel 成员。</p>
<p>其中，master 进程列中的每一个元素，表示master进程与对应的每个 worker 进程之间的匿名套接字对。</p>
<p>而每一个 worker 进程列中的每一个元素，表示该 worker 进程与对应的每个 worker 进程之间的匿名套接字对。当然这只是一个粗略的说法，与真实情况并不完全相符，还有很多细节需要进一步阐述。</p>
<p>我们直接借助《深入剖析 Nginx》，直接看下图的实例：
<img src="/img/ipc-5.jpg" alt="ipc-5.jpg"></p>
<p>再次感谢《深入剖析 Nginx》的作者高群凯，觉得在这里我没法表达的比他更好了。所以下面会引用很多该书中的内容。</p>
<p>在上表中，每一个单元格的内容分别表示 <code>channel[0]</code> 和 <code>channel[1]</code> 的值，-1表示这之前是描述符，但在之后被主动 close() 掉了，0 表示这一直都无对应的描述符，其他数字表示对应的描述符值。</p>
<p>每一列数据都表示该列所对应进程与其他进程进行通信的描述符，如果当前列所对应进程为父进程，那么它与其它进程进行通信的描述符都为 <code>channel[0]</code> (其实 <code>channel[1]</code> 也可以)；如果当前列所对应的进程为子进程，那么它与父进程进行通信的描述符为 <code>channel[1]</code>（注：这里书中说的太简略，应该为如果当前列所对应的进程为子进程，那么它与父进程进行通信的描述符为该进程的 ngx_processes 数组中，与本进程对应的元素中的 <code>channel[1]</code>，在图中即为标粗的对角线部分，即 <code>[-1,7]</code>，<code>[-1,9]</code>，<code>[-1,11]</code>，<code>[-1,13]</code>这四对），与其它子进程进行通信的描述符都为本进程的 <code>ngx_processes</code> 数组中与该其它进程对应元素的 <code>channel[0]</code>。</p>
<p>比如，<code>[3，7]</code> 单元格表示，如果父进程向 worker0 发送消息，需要使用 <code>channel[0]</code>，即描述符 3，实际上 <code>channel[1]</code> 也可以，它的 <code>channel[1]</code> 为 7，没有被 close() 关闭掉，但一直也没有被使用，所以没有影响，不过按道理应该关闭才是。</p>
<p>再比如，<code>[-1，7]</code> 单元格表示如果 worker0 向 master 进程发送消息，需要使用 <code>channel[1]</code>，即描述符 7，它的 <code>channel[0]</code> 为 -1，表示已经 close() 关闭掉了（Nginx某些地方调用 close() 时并没有设置对应变量为 -1，这里只是为了更好的说明，将已经 close() 掉的描述符全部标记为 -1）。</p>
<p>越是后生成的 worker 进程，其 <code>ngx_processes</code> 数组的元素中，<code>channel[0]</code> 与父进程对应的 <code>ngx_processes</code> 数组的元素中的 <code>channel[0]</code> 值相同的越多，因为基本都是继承而来，但前面生成的 worker 进程，其 <code>channel[0]</code> 是通过进程间调用 sendmsg 传递获得的，所以与父进程对应的 <code>channel[0]</code> 不一定相等。比如，如果 worker0 向 worker3 发送消息，需要使用worker0 进程的 <code>ngx_processes[3]</code> 元素的 <code>channel[0]</code>，即描述符 10，而对应 master 进程的 <code>ngx_processes[3]</code> 元素的 <code>channel[0]</code> 却是 12。虽然它们在各自进程里表现为不同的整型数字，但在内核里表示同一个描述符结构，即不管是 worker0 往描述符 10 写数据，还是master 往描述符 12 写数据，worker3 都能通过描述符 13 正确读取到这些数据，至于 worker3 怎么识别它读到的数据是来自 worker0，还是 master，就得靠其他收到的数据特征，比如pid，来做标记区分。</p>
<p>关于上段讲的，一个子进程如何区分接收到的数据是来自哪一个进程，我们可以看一下 Nginx-1.6.2中的一段代码：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000">ngx_int_t</span>  
<span style="color:#000">ngx_write_channel</span>(<span style="color:#000">ngx_socket_t</span> <span style="color:#000">s</span>, <span style="color:#000">ngx_channel_t</span> *<span style="color:#000">ch</span>, <span style="color:#000">size_t</span> <span style="color:#000">size</span>,  
    <span style="color:#000">ngx_log_t</span> *<span style="color:#000">log</span>)  
{  
    <span style="color:#000">ssize_t</span>             <span style="color:#000">n</span>;  
    <span style="color:#000">ngx_err_t</span>           <span style="color:#000">err</span>;  
    <span style="color:#00f">struct</span> <span style="color:#000">iovec</span>        <span style="color:#000">iov</span>[<span style="color:#3af">1</span>];  
    <span style="color:#00f">struct</span> <span style="color:#000">msghdr</span>       <span style="color:#000">msg</span>;  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">if (NGX_HAVE_MSGHDR_MSG_CONTROL)  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
    <span style="color:#00f">union</span> {  
        <span style="color:#00f">struct</span> <span style="color:#000">cmsghdr</span>  <span style="color:#000">cm</span>;  
        <span style="color:#00f">char</span>            <span style="color:#000">space</span>[<span style="color:#000">CMSG_SPACE</span>(<span style="color:#00f">sizeof</span>(<span style="color:#00f">int</span>))];  
    } <span style="color:#000">cmsg</span>;  
  
    <span style="color:#00f">if</span> (<span style="color:#000">ch</span>-&gt;<span style="color:#000">fd</span> == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_control</span> = <span style="color:#000">NULL</span>;  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_controllen</span> = <span style="color:#3af">0</span>;  
  
    } <span style="color:#00f">else</span> {  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_control</span> = (<span style="color:#000">caddr_t</span>) &amp;<span style="color:#000">cmsg</span>;  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_controllen</span> = <span style="color:#00f">sizeof</span>(<span style="color:#000">cmsg</span>);  
  
        <span style="color:#000">ngx_memzero</span>(&amp;<span style="color:#000">cmsg</span>, <span style="color:#00f">sizeof</span>(<span style="color:#000">cmsg</span>));  
  
        <span style="color:#000">cmsg</span>.<span style="color:#000">cm</span>.<span style="color:#000">cmsg_len</span> = <span style="color:#000">CMSG_LEN</span>(<span style="color:#00f">sizeof</span>(<span style="color:#00f">int</span>));  
        <span style="color:#000">cmsg</span>.<span style="color:#000">cm</span>.<span style="color:#000">cmsg_level</span> = <span style="color:#000">SOL_SOCKET</span>;  
        <span style="color:#000">cmsg</span>.<span style="color:#000">cm</span>.<span style="color:#000">cmsg_type</span> = <span style="color:#000">SCM_RIGHTS</span>;  
  
        <span style="color:#888;font-style:italic">/*  
</span><span style="color:#888;font-style:italic">         * We have to use ngx_memcpy() instead of simple  
</span><span style="color:#888;font-style:italic">         *   *(int *) CMSG_DATA(&amp;cmsg.cm) = ch-&gt;fd;  
</span><span style="color:#888;font-style:italic">         * because some gcc 4.4 with -O2/3/s optimization issues the warning:  
</span><span style="color:#888;font-style:italic">         *   dereferencing type-punned pointer will break strict-aliasing rules  
</span><span style="color:#888;font-style:italic">         *  
</span><span style="color:#888;font-style:italic">         * Fortunately, gcc with -O1 compiles this ngx_memcpy()  
</span><span style="color:#888;font-style:italic">         * in the same simple assignment as in the code above  
</span><span style="color:#888;font-style:italic">         */</span>  
  
        <span style="color:#000">ngx_memcpy</span>(<span style="color:#000">CMSG_DATA</span>(&amp;<span style="color:#000">cmsg</span>.<span style="color:#000">cm</span>), &amp;<span style="color:#000">ch</span>-&gt;<span style="color:#000">fd</span>, <span style="color:#00f">sizeof</span>(<span style="color:#00f">int</span>));  
    }  
  
    <span style="color:#000">msg</span>.<span style="color:#000">msg_flags</span> = <span style="color:#3af">0</span>;  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">else  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
    <span style="color:#00f">if</span> (<span style="color:#000">ch</span>-&gt;<span style="color:#000">fd</span> == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_accrights</span> = <span style="color:#000">NULL</span>;  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_accrightslen</span> = <span style="color:#3af">0</span>;  
  
    } <span style="color:#00f">else</span> {  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_accrights</span> = (<span style="color:#000">caddr_t</span>) &amp;<span style="color:#000">ch</span>-&gt;<span style="color:#000">fd</span>;  
        <span style="color:#000">msg</span>.<span style="color:#000">msg_accrightslen</span> = <span style="color:#00f">sizeof</span>(<span style="color:#00f">int</span>);  
    }  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">endif  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
    <span style="color:#000">iov</span>[<span style="color:#3af">0</span>].<span style="color:#000">iov_base</span> = (<span style="color:#00f">char</span> *) <span style="color:#000">ch</span>;  
    <span style="color:#000">iov</span>[<span style="color:#3af">0</span>].<span style="color:#000">iov_len</span> = <span style="color:#000">size</span>;  
  
    <span style="color:#000">msg</span>.<span style="color:#000">msg_name</span> = <span style="color:#000">NULL</span>;  
    <span style="color:#000">msg</span>.<span style="color:#000">msg_namelen</span> = <span style="color:#3af">0</span>;  
    <span style="color:#000">msg</span>.<span style="color:#000">msg_iov</span> = <span style="color:#000">iov</span>;  
    <span style="color:#000">msg</span>.<span style="color:#000">msg_iovlen</span> = <span style="color:#3af">1</span>;  
  
    <span style="color:#000">n</span> = <span style="color:#000">sendmsg</span>(<span style="color:#000">s</span>, &amp;<span style="color:#000">msg</span>, <span style="color:#3af">0</span>);  
  
    <span style="color:#00f">if</span> (<span style="color:#000">n</span> == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">err</span> = <span style="color:#000">ngx_errno</span>;  
        <span style="color:#00f">if</span> (<span style="color:#000">err</span> == <span style="color:#000">NGX_EAGAIN</span>) {  
            <span style="color:#00f">return</span> <span style="color:#000">NGX_AGAIN</span>;  
        }  
  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">log</span>, <span style="color:#000">err</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">sendmsg() failed</span><span style="color:#5a2">&#34;</span>);  
        <span style="color:#00f">return</span> <span style="color:#000">NGX_ERROR</span>;  
    }  
  
    <span style="color:#00f">return</span> <span style="color:#000">NGX_OK</span>;  
}  
</code></pre></div><p>在调用时，参数 ch 即为发送的数据部分，其类型定义如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> {  
     <span style="color:#000">ngx_uint_t</span>  <span style="color:#000">command</span>;  
     <span style="color:#000">ngx_pid_t</span>   <span style="color:#000">pid</span>;  
     <span style="color:#000">ngx_int_t</span>   <span style="color:#000">slot</span>;  
     <span style="color:#000">ngx_fd_t</span>    <span style="color:#000">fd</span>;  
} <span style="color:#000">ngx_channel_t</span>;  
</code></pre></div><p>可见，其中就包含了发送方的pid。</p>
<p>最后，就目前 Nginx 代码来看，子进程并没有往父进程发送任何消息，子进程之间也没有相互通信的逻辑。也许是因为 Nginx 有其他一些更好的进程通信方式，比如共享内存等，所以这种 channel 通信目前仅作为父进程往子进程发送消息使用。但由于有这个架构在，可以很轻松使用 channel 机制来完成各进程间的通信任务。</p>
<h3 id="13-nginx-中的相关代码流程">1.3 Nginx 中的相关代码流程</h3>
<p>下面，将上面所讲的内容，在 Nginx 代码中的流程，大概梳理一遍。本文所有代码片段，均来自于nginx-1.6.2。</p>
<p>首先是 main 函数调用 <code>ngx_master_process_cycle</code>：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#00f">if</span> (<span style="color:#000">ngx_process</span> == <span style="color:#000">NGX_PROCESS_SINGLE</span>) {  
        <span style="color:#000">ngx_single_process_cycle</span>(<span style="color:#000">cycle</span>);  
  
    } <span style="color:#00f">else</span> {  
        <span style="color:#000">ngx_master_process_cycle</span>(<span style="color:#000">cycle</span>);  
    }  
  
    <span style="color:#00f">return</span> <span style="color:#3af">0</span>;  
</code></pre></div><p>ngx_master_process_cycle<code>调用</code>ngx_start_worker_processes`：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000">ccf</span> = (<span style="color:#000">ngx_core_conf_t</span> *) <span style="color:#000">ngx_get_conf</span>(<span style="color:#000">cycle</span>-&gt;<span style="color:#000">conf_ctx</span>, <span style="color:#000">ngx_core_module</span>);  
  
<span style="color:#000">ngx_start_worker_processes</span>(<span style="color:#000">cycle</span>, <span style="color:#000">ccf</span>-&gt;<span style="color:#000">worker_processes</span>,  
                           <span style="color:#000">NGX_PROCESS_RESPAWN</span>);  
<span style="color:#000">ngx_start_cache_manager_processes</span>(<span style="color:#000">cycle</span>, <span style="color:#3af">0</span>);  
</code></pre></div><p>在 <code>ngx_start_worker_processes</code> 函数中，完成对所有 worker 进程的 fork 操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>  
<span style="color:#000">ngx_start_worker_processes</span>(<span style="color:#000">ngx_cycle_t</span> *<span style="color:#000">cycle</span>, <span style="color:#000">ngx_int_t</span> <span style="color:#000">n</span>, <span style="color:#000">ngx_int_t</span> <span style="color:#000">type</span>)  
{  
    <span style="color:#000">ngx_int_t</span>      <span style="color:#000">i</span>;  
    <span style="color:#000">ngx_channel_t</span>  <span style="color:#000">ch</span>;  
  
    <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_NOTICE</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>, <span style="color:#3af">0</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">start worker processes</span><span style="color:#5a2">&#34;</span>);  
  
    <span style="color:#000">ngx_memzero</span>(&amp;<span style="color:#000">ch</span>, <span style="color:#00f">sizeof</span>(<span style="color:#000">ngx_channel_t</span>));  
  
    <span style="color:#000">ch</span>.<span style="color:#000">command</span> = <span style="color:#000">NGX_CMD_OPEN_CHANNEL</span>;  
  
    <span style="color:#00f">for</span> (<span style="color:#000">i</span> = <span style="color:#3af">0</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">n</span>; <span style="color:#000">i</span>++) {  
  
        <span style="color:#000">ngx_spawn_process</span>(<span style="color:#000">cycle</span>, <span style="color:#000">ngx_worker_process_cycle</span>,  
                          (<span style="color:#00f">void</span> *) (<span style="color:#000">intptr_t</span>) <span style="color:#000">i</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">worker process</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">type</span>);  
  
        <span style="color:#000">ch</span>.<span style="color:#000">pid</span> = <span style="color:#000">ngx_processes</span>[<span style="color:#000">ngx_process_slot</span>].<span style="color:#000">pid</span>;  
        <span style="color:#000">ch</span>.<span style="color:#000">slot</span> = <span style="color:#000">ngx_process_slot</span>;  
        <span style="color:#000">ch</span>.<span style="color:#000">fd</span> = <span style="color:#000">ngx_processes</span>[<span style="color:#000">ngx_process_slot</span>].<span style="color:#000">channel</span>[<span style="color:#3af">0</span>];  
  
        <span style="color:#000">ngx_pass_open_channel</span>(<span style="color:#000">cycle</span>, &amp;<span style="color:#000">ch</span>);  
    }  
}  
</code></pre></div><p>上述代码调用的 <code>ngx_spawn_process</code> 即完成具体的 <code>socketpair()</code> 操作和 fork 操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000">ngx_pid_t</span>  
<span style="color:#000">ngx_spawn_process</span>(<span style="color:#000">ngx_cycle_t</span> *<span style="color:#000">cycle</span>, <span style="color:#000">ngx_spawn_proc_pt</span> <span style="color:#000">proc</span>, <span style="color:#00f">void</span> *<span style="color:#000">data</span>,  
     <span style="color:#00f">char</span> *<span style="color:#000">name</span>, <span style="color:#000">ngx_int_t</span> <span style="color:#000">respawn</span>)  
{  
       ......  
       <span style="color:#00f">if</span> (<span style="color:#000">socketpair</span>(<span style="color:#000">AF_UNIX</span>, <span style="color:#000">SOCK_STREAM</span>, <span style="color:#3af">0</span>, <span style="color:#000">ngx_processes</span>[<span style="color:#000">s</span>].<span style="color:#000">channel</span>) == -<span style="color:#3af">1</span>)  
        {  
            <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                          <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">socketpair() failed while spawning </span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">%s</span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">name</span>);  
            <span style="color:#00f">return</span> <span style="color:#000">NGX_INVALID_PID</span>;  
        }  
        ......  
        <span style="color:#000">ngx_channel</span> = <span style="color:#000">ngx_processes</span>[<span style="color:#000">s</span>].<span style="color:#000">channel</span>[<span style="color:#3af">1</span>];  
        ......  
        <span style="color:#000">ngx_process_slot</span> = <span style="color:#000">s</span>;  
        <span style="color:#000">pid</span> = <span style="color:#000">fork</span>();  
        ......  
}  
</code></pre></div><p>在上一段代码中可以看到，master 进程在调用 socketpair 后，将生成的 <code>channel[1]</code> 保存在全局变量 <code>ngx_channel</code> 中，<code>ngx_channel</code> 全局变量的作用是，子进程中会使用该全局变量，并加入到自己的事件集中，达到的效果即是子进程将 <code>channel[1]</code> 加入到自己的事件集中。</p>
<p>话分两头，我们先来具体看看子进程的流程。</p>
<p>在主进程执行完 fork 之后，<code>ngx_start_worker_processes</code> 会调用 proc 回调：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">   <span style="color:#000">pid</span> = <span style="color:#000">fork</span>();  
  
    <span style="color:#00f">switch</span> (<span style="color:#000">pid</span>) {  
  
    <span style="color:#00f">case</span> -<span style="color:#3af">1</span>:  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">fork() failed while spawning </span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">%s</span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">name</span>);  
        <span style="color:#000">ngx_close_channel</span>(<span style="color:#000">ngx_processes</span>[<span style="color:#000">s</span>].<span style="color:#000">channel</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>);  
        <span style="color:#00f">return</span> <span style="color:#000">NGX_INVALID_PID</span>;  
  
    <span style="color:#00f">case</span> <span style="color:#3af">0</span>:  
        <span style="color:#000">ngx_pid</span> = <span style="color:#000">ngx_getpid</span>();  
        <span style="color:#000">proc</span>(<span style="color:#000">cycle</span>, <span style="color:#000">data</span>);  
        <span style="color:#00f">break</span>;  
  
    <span style="color:#00f">default</span>:  
        <span style="color:#00f">break</span>;  
    }  
</code></pre></div><p>其中，proc 即为 <code>ngx_worker_process_cycle</code>。<code>ngx_worker_process_cycle</code> 会调用<code>ngx_worker_process_init</code> 函数，子进程将从父进程处继承到的 <code>channel[1]</code> 加入到自己的事件集中，就是在这个函数中完成的：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>  
<span style="color:#000">ngx_worker_process_init</span>(<span style="color:#000">ngx_cycle_t</span> *<span style="color:#000">cycle</span>, <span style="color:#000">ngx_int_t</span> <span style="color:#000">worker</span>)  
{  
......  
   <span style="color:#00f">for</span> (<span style="color:#000">n</span> = <span style="color:#3af">0</span>; <span style="color:#000">n</span> &lt; <span style="color:#000">ngx_last_process</span>; <span style="color:#000">n</span>++) {  
  
        <span style="color:#00f">if</span> (<span style="color:#000">ngx_processes</span>[<span style="color:#000">n</span>].<span style="color:#000">pid</span> == -<span style="color:#3af">1</span>) {  
            <span style="color:#00f">continue</span>;  
        }  
  
        <span style="color:#00f">if</span> (<span style="color:#000">n</span> == <span style="color:#000">ngx_process_slot</span>) {  
            <span style="color:#00f">continue</span>;  
        }  
  
        <span style="color:#00f">if</span> (<span style="color:#000">ngx_processes</span>[<span style="color:#000">n</span>].<span style="color:#000">channel</span>[<span style="color:#3af">1</span>] == -<span style="color:#3af">1</span>) {  
            <span style="color:#00f">continue</span>;  
        }  
  
        <span style="color:#00f">if</span> (<span style="color:#000">close</span>(<span style="color:#000">ngx_processes</span>[<span style="color:#000">n</span>].<span style="color:#000">channel</span>[<span style="color:#3af">1</span>]) == -<span style="color:#3af">1</span>) {  
            <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                          <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">close() channel failed</span><span style="color:#5a2">&#34;</span>);  
        }  
    }  
  
    <span style="color:#00f">if</span> (<span style="color:#000">close</span>(<span style="color:#000">ngx_processes</span>[<span style="color:#000">ngx_process_slot</span>].<span style="color:#000">channel</span>[<span style="color:#3af">0</span>]) == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">close() channel failed</span><span style="color:#5a2">&#34;</span>);  
    }  
  
<span style="color:#888;font-style:italic">#if 0</span><span style="color:#888;font-style:italic">  
</span><span style="color:#888;font-style:italic"></span><span style="color:#888;font-style:italic">    ngx_last_process = 0;  
</span><span style="color:#888;font-style:italic"></span><span style="color:#888;font-style:italic">#endif  
</span><span style="color:#888;font-style:italic"></span>  
    <span style="color:#00f">if</span> (<span style="color:#000">ngx_add_channel_event</span>(<span style="color:#000">cycle</span>, <span style="color:#000">ngx_channel</span>, <span style="color:#000">NGX_READ_EVENT</span>,  
                              <span style="color:#000">ngx_channel_handler</span>)  
        == <span style="color:#000">NGX_ERROR</span>)  
    {  
        <span style="color:#888;font-style:italic">/* fatal */</span>  
        <span style="color:#000">exit</span>(<span style="color:#3af">2</span>);  
    }  
......  
}  
</code></pre></div><p>具体的将 <code>channel[1]</code> 添加到事件集中的操作，是由 <code>ngx_add_channel_event</code> 来完成的，对应的回调处理函数为 <code>ngx_channel_handler</code>，同时我们看到，在添加之前，还进行了很多 close 的工作，这就于之前的示例表里，那些描述符为 -1 的表项相对应了。</p>
<p>此时，子进程已经将从父进程那里继承来的 <code>channel[1]</code> 加入到了自己的监听事件集中，这样，一个子进程从自己的 <code>ngx_processses</code> 数组中，对应本进程的那一个元素中的 <code>channel[1]</code> 中，即可读取来自其他进程的消息。收到消息时，将执行设置好的回调函数<code>ngx_channel_handler</code>，把接收到的新子进程的相关信息存储在自己的全局变量<code>ngx_processes</code> 数组内。见下面的代码：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>  
<span style="color:#000">ngx_channel_handler</span>(<span style="color:#000">ngx_event_t</span> *<span style="color:#000">ev</span>)  
{  
    ......  
          <span style="color:#00f">case</span> <span style="color:#000">NGX_CMD_OPEN_CHANNEL</span>:  
  
            <span style="color:#000">ngx_log_debug3</span>(<span style="color:#000">NGX_LOG_DEBUG_CORE</span>, <span style="color:#000">ev</span>-&gt;<span style="color:#000">log</span>, <span style="color:#3af">0</span>,  
                           <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">get channel s:%i pid:%P fd:%d</span><span style="color:#5a2">&#34;</span>,  
                           <span style="color:#000">ch</span>.<span style="color:#000">slot</span>, <span style="color:#000">ch</span>.<span style="color:#000">pid</span>, <span style="color:#000">ch</span>.<span style="color:#000">fd</span>);  
  
            <span style="color:#000">ngx_processes</span>[<span style="color:#000">ch</span>.<span style="color:#000">slot</span>].<span style="color:#000">pid</span> = <span style="color:#000">ch</span>.<span style="color:#000">pid</span>;  
            <span style="color:#000">ngx_processes</span>[<span style="color:#000">ch</span>.<span style="color:#000">slot</span>].<span style="color:#000">channel</span>[<span style="color:#3af">0</span>] = <span style="color:#000">ch</span>.<span style="color:#000">fd</span>;  
            <span style="color:#00f">break</span>;  
    ......  
}  
</code></pre></div><p>我们再回到父进程中。</p>
<p>父进程在从 <code>ngx_spawn_process</code> 返回后，回来继续执行 <code>ngx_start_worker_processes</code>：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>  
<span style="color:#000">ngx_start_worker_processes</span>(<span style="color:#000">ngx_cycle_t</span> *<span style="color:#000">cycle</span>, <span style="color:#000">ngx_int_t</span> <span style="color:#000">n</span>, <span style="color:#000">ngx_int_t</span> <span style="color:#000">type</span>)  
{  
    <span style="color:#000">ngx_int_t</span>      <span style="color:#000">i</span>;  
    <span style="color:#000">ngx_channel_t</span>  <span style="color:#000">ch</span>;  
  
    <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_NOTICE</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>, <span style="color:#3af">0</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">start worker processes</span><span style="color:#5a2">&#34;</span>);  
  
    <span style="color:#000">ngx_memzero</span>(&amp;<span style="color:#000">ch</span>, <span style="color:#00f">sizeof</span>(<span style="color:#000">ngx_channel_t</span>));  
  
    <span style="color:#000">ch</span>.<span style="color:#000">command</span> = <span style="color:#000">NGX_CMD_OPEN_CHANNEL</span>;  
  
    <span style="color:#00f">for</span> (<span style="color:#000">i</span> = <span style="color:#3af">0</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">n</span>; <span style="color:#000">i</span>++) {  
  
        <span style="color:#000">ngx_spawn_process</span>(<span style="color:#000">cycle</span>, <span style="color:#000">ngx_worker_process_cycle</span>,  
                          (<span style="color:#00f">void</span> *) (<span style="color:#000">intptr_t</span>) <span style="color:#000">i</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">worker process</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">type</span>);  
  
        <span style="color:#000">ch</span>.<span style="color:#000">pid</span> = <span style="color:#000">ngx_processes</span>[<span style="color:#000">ngx_process_slot</span>].<span style="color:#000">pid</span>;  
        <span style="color:#000">ch</span>.<span style="color:#000">slot</span> = <span style="color:#000">ngx_process_slot</span>;  
        <span style="color:#000">ch</span>.<span style="color:#000">fd</span> = <span style="color:#000">ngx_processes</span>[<span style="color:#000">ngx_process_slot</span>].<span style="color:#000">channel</span>[<span style="color:#3af">0</span>];  
  
        <span style="color:#000">ngx_pass_open_channel</span>(<span style="color:#000">cycle</span>, &amp;<span style="color:#000">ch</span>);  
    }  
}  
</code></pre></div><p>其中的 for 循环即表示，父进程会把刚刚生成的子进程的 <code>channel[0]</code>，放在一条<strong>消息</strong>的内容中发送给之前生成的子进程。<strong>消息</strong>的格式定义为：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> {  
     <span style="color:#000">ngx_uint_t</span>  <span style="color:#000">command</span>;  
     <span style="color:#000">ngx_pid_t</span>   <span style="color:#000">pid</span>;  
     <span style="color:#000">ngx_int_t</span>   <span style="color:#000">slot</span>;  
     <span style="color:#000">ngx_fd_t</span>    <span style="color:#000">fd</span>;  
} <span style="color:#000">ngx_channel_t</span>;  
</code></pre></div><p>我们看下 <code>ngx_pass_open_channel</code> 函数：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>  
<span style="color:#000">ngx_pass_open_channel</span>(<span style="color:#000">ngx_cycle_t</span> *<span style="color:#000">cycle</span>, <span style="color:#000">ngx_channel_t</span> *<span style="color:#000">ch</span>)  
{  
    <span style="color:#000">ngx_int_t</span>  <span style="color:#000">i</span>;  
  
    <span style="color:#00f">for</span> (<span style="color:#000">i</span> = <span style="color:#3af">0</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">ngx_last_process</span>; <span style="color:#000">i</span>++) {  
  
        <span style="color:#00f">if</span> (<span style="color:#000">i</span> == <span style="color:#000">ngx_process_slot</span>  
            || <span style="color:#000">ngx_processes</span>[<span style="color:#000">i</span>].<span style="color:#000">pid</span> == -<span style="color:#3af">1</span>  
            || <span style="color:#000">ngx_processes</span>[<span style="color:#000">i</span>].<span style="color:#000">channel</span>[<span style="color:#3af">0</span>] == -<span style="color:#3af">1</span>)  
        {  
            <span style="color:#00f">continue</span>;  
        }  
  
        <span style="color:#000">ngx_log_debug6</span>(<span style="color:#000">NGX_LOG_DEBUG_CORE</span>, <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>, <span style="color:#3af">0</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">pass channel s:%d pid:%P fd:%d to s:%i pid:%P fd:%d</span><span style="color:#5a2">&#34;</span>,  
                      <span style="color:#000">ch</span>-&gt;<span style="color:#000">slot</span>, <span style="color:#000">ch</span>-&gt;<span style="color:#000">pid</span>, <span style="color:#000">ch</span>-&gt;<span style="color:#000">fd</span>,  
                      <span style="color:#000">i</span>, <span style="color:#000">ngx_processes</span>[<span style="color:#000">i</span>].<span style="color:#000">pid</span>,  
                      <span style="color:#000">ngx_processes</span>[<span style="color:#000">i</span>].<span style="color:#000">channel</span>[<span style="color:#3af">0</span>]);  
  
        <span style="color:#888;font-style:italic">/* TODO: NGX_AGAIN */</span>  
  
        <span style="color:#000">ngx_write_channel</span>(<span style="color:#000">ngx_processes</span>[<span style="color:#000">i</span>].<span style="color:#000">channel</span>[<span style="color:#3af">0</span>],  
                          <span style="color:#000">ch</span>, <span style="color:#00f">sizeof</span>(<span style="color:#000">ngx_channel_t</span>), <span style="color:#000">cycle</span>-&gt;<span style="color:#000">log</span>);  
    }  
}  
</code></pre></div><p>从该函数定义中，可以很清晰的看到“往之前生成的每个进程发送消息”。对之前的每个子进程，具体消息发送工作，是由函数 <code>ngx_write_channel</code> 完成的。</p>
<p><code>ngx_write_channel</code> 函数的第一个参数是之前某个进程从 master 进程继承来的 <code>channel[0]</code>，第二个参数是发送的内容。其中包含了当前进程的 pid、slot号、command 等信息，最重要的是，包含了当前子进程的 <code>channel[0]</code>，其实是实现了一个简单的协议。注意，当前子进程的 <code>channel[0]</code> 虽然存在 <code>ngx_channel_t</code> 类型的消息体中，但真正文件描述符的传递操作，是 <code>ngx_write_channel</code> 通过发送控制信息来完成的。接收进程虽然在接收到的消息体中获得了发送进程的 <code>channel[0]</code> 这个值，但并不能直接使用，必须根据控制信息来获取一个新的文件描述符。参看<a href="jin_cheng_jian_chuan_di_wen_jian_miao_shu_fu.md">进程间传递文件描述符</a>。</p>
<p>至此，父子进程间的配合，使得所有的子进程均拥有了其他子进程的 <code>channel[0]</code>，而另一方面，由于所有子进程的 <code>channel[1]</code> 已加入到自己的监听事件集，所以子进程之间的通信通道即被建立起来。</p>
<p>值得一提的是，父进程在调用 socketpair() 产生一个匿名套接字对后，再 fork 出一个子进程，那么现在有 4 个文件描述符了。其实对这 4 个文件描述符中的任何一个进行写入，从其他3个描述符中的任何一个均可以进行读取操作。</p>
<p>但 Nginx 通过一些 close() 操作，有意达到这样一种目的：</p>
<ul>
<li>对任何一个子进程，其 <code>ngx_processes</code> 数组中，对应其它进程的元素，其 <code>channel[0]</code> 用来向“该其他进程”发送消息。</li>
<li>对任何一个子进程，其 <code>ngx_processes</code> 数组中，对应本进程的元素，其 <code>channel[1]</code> 用来接收来自其他进程的消息，这个其他进程既包括其他子进程，也包括 master 进程。至于如何区分是来自哪个进程，以及该消息是用来做什么的，则通过判断 ngx_channel_t 类型的消息的comman、pid、slot等成员来协商。</li>
<li>对 master 进程，其 <code>ngx_processes</code> 数组的中，对应相应子进程的元素的 <code>channel[0]</code>，用来向该子进程发送消息。注:其实 <code>channel[1]</code> 也可以，但按常理，master 进程的 <code>ngx_processes</code> 数组所有元素的 <code>channel[1]</code> 应该关闭的。</li>
</ul>
<h2 id="2-nginx-中的共享内存">2. Nginx 中的共享内存</h2>
<h3 id="21-概述">2.1 概述</h3>
<blockquote>
<p>共享内存是 Linux 下提供的最基本的进程间通信方法，它通过 mmap 或者 shmget 系统调用在内存中创建了一块连续的线性地址空间，而通过 munmap 或者 shmdt 系统调用可以释放这块内存。使用共享内存的好处是当多个进程使用同一块共享内存时，在任何一个进程修改了共享内存中的内容后，其他进程通过访问这段共享内存都能够得到修改后的内容。</p>
<p>陶辉《深入理解Nginx》</p>
</blockquote>
<p>共享内存可以说是最有用的进程间通信方式，也是最快的 IPC 形式。两个不同进程 A、B 共享内存的意思是，同一块物理内存被映射到进程 A、B 各自的进程地址空间。进程 A 可以即时看到进程 B 对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</p>
<p>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>Linux 中，共享内存可以通过两个系统系统调用来获得，mmap 和shmget，分别属于不同的标准，这不在本文的关注范围之内。mmap 语义上比 shmget 更通用，因为它最一般的做法，是将一个打开的实体文件，映射到一段连续的内存中，各个进程可以根据各自的权限对该段内存进行相应的读写操作，其他进程则可以看到其他进程写入的结果。而 shmget 在语义上相当于是匿名的 mmap，即不关注实体文件，直接在内存中开辟这块共享区域，mmap 通过设置调用时的参数，也可达到这种效果，一种方法是映射 /dev/zero 设备,另一种是使用 MAP_ANON选 项。至于 mmap 和 shmget 的效率，跟不同的内核实现相关，不在本文关注范围内。</p>
<p>除了上面的简单描述外，本文不打算仔细介绍 mmap 和 shmget 的使用。有如下相关资料可以参考：</p>
<ol>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html">Linux环境进程间通信（五）: 共享内存（上）</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html">Linux环境进程间通信（五）: 共享内存（下）</a></li>
<li>APUE,14.8,15.9</li>
</ol>
<h3 id="22-nginx-中的实现">2.2 Nginx 中的实现</h3>
<p>那么，在 Nginx 中，到底是选用 mmap 映射到 /dev/null，还是使用 MAP_ANON 选项调用mmap，或者是使用 shmget 呢？看相关实现的代码就会一目了然：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#888;font-style:italic">/*  
</span><span style="color:#888;font-style:italic"> * Copyright (C) Igor Sysoev  
</span><span style="color:#888;font-style:italic"> * Copyright (C) Nginx, Inc.  
</span><span style="color:#888;font-style:italic"> */</span>  
  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">include</span> <span style="color:#888;font-style:italic">&lt;ngx_config.h&gt;  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span><span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">include</span> <span style="color:#888;font-style:italic">&lt;ngx_core.h&gt;  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">if (NGX_HAVE_MAP_ANON)  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
<span style="color:#000">ngx_int_t</span>  
<span style="color:#000">ngx_shm_alloc</span>(<span style="color:#000">ngx_shm_t</span> *<span style="color:#000">shm</span>)  
{  
    <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> = (<span style="color:#000">u_char</span> *) <span style="color:#000">mmap</span>(<span style="color:#000">NULL</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>,  
                                <span style="color:#000">PROT_READ</span>|<span style="color:#000">PROT_WRITE</span>,  
                                <span style="color:#000">MAP_ANON</span>|<span style="color:#000">MAP_SHARED</span>, -<span style="color:#3af">1</span>, <span style="color:#3af">0</span>);  
  
    <span style="color:#00f">if</span> (<span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> == <span style="color:#000">MAP_FAILED</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">mmap(MAP_ANON|MAP_SHARED, %uz) failed</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>);  
        <span style="color:#00f">return</span> <span style="color:#000">NGX_ERROR</span>;  
    }  
  
    <span style="color:#00f">return</span> <span style="color:#000">NGX_OK</span>;  
}  
  
  
<span style="color:#00f">void</span>  
<span style="color:#000">ngx_shm_free</span>(<span style="color:#000">ngx_shm_t</span> *<span style="color:#000">shm</span>)  
{  
    <span style="color:#00f">if</span> (<span style="color:#000">munmap</span>((<span style="color:#00f">void</span> *) <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>) == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">munmap(%p, %uz) failed</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>);  
    }  
}  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">elif (NGX_HAVE_MAP_DEVZERO)  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
<span style="color:#000">ngx_int_t</span>  
<span style="color:#000">ngx_shm_alloc</span>(<span style="color:#000">ngx_shm_t</span> *<span style="color:#000">shm</span>)  
{  
    <span style="color:#000">ngx_fd_t</span>  <span style="color:#000">fd</span>;  
  
    <span style="color:#000">fd</span> = <span style="color:#000">open</span>(<span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">/dev/zero</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">O_RDWR</span>);  
  
    <span style="color:#00f">if</span> (<span style="color:#000">fd</span> == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">open(</span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">/dev/zero</span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">) failed</span><span style="color:#5a2">&#34;</span>);  
        <span style="color:#00f">return</span> <span style="color:#000">NGX_ERROR</span>;  
    }  
  
    <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> = (<span style="color:#000">u_char</span> *) <span style="color:#000">mmap</span>(<span style="color:#000">NULL</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>, <span style="color:#000">PROT_READ</span>|<span style="color:#000">PROT_WRITE</span>,  
                                <span style="color:#000">MAP_SHARED</span>, <span style="color:#000">fd</span>, <span style="color:#3af">0</span>);  
  
    <span style="color:#00f">if</span> (<span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> == <span style="color:#000">MAP_FAILED</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">mmap(/dev/zero, MAP_SHARED, %uz) failed</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>);  
    }  
  
    <span style="color:#00f">if</span> (<span style="color:#000">close</span>(<span style="color:#000">fd</span>) == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">close(</span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">/dev/zero</span><span style="color:#5a2">\&#34;</span><span style="color:#5a2">) failed</span><span style="color:#5a2">&#34;</span>);  
    }  
  
    <span style="color:#00f">return</span> (<span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> == <span style="color:#000">MAP_FAILED</span>) ? <span style="color:#000">NGX_ERROR</span> : <span style="color:#000">NGX_OK</span>;  
}  
  
  
<span style="color:#00f">void</span>  
<span style="color:#000">ngx_shm_free</span>(<span style="color:#000">ngx_shm_t</span> *<span style="color:#000">shm</span>)  
{  
    <span style="color:#00f">if</span> (<span style="color:#000">munmap</span>((<span style="color:#00f">void</span> *) <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>) == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">munmap(%p, %uz) failed</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>);  
    }  
}  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">elif (NGX_HAVE_SYSVSHM)  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">include</span> <span style="color:#888;font-style:italic">&lt;sys/ipc.h&gt;  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span><span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">include</span> <span style="color:#888;font-style:italic">&lt;sys/shm.h&gt;  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
  
<span style="color:#000">ngx_int_t</span>  
<span style="color:#000">ngx_shm_alloc</span>(<span style="color:#000">ngx_shm_t</span> *<span style="color:#000">shm</span>)  
{  
    <span style="color:#00f">int</span>  <span style="color:#000">id</span>;  
  
    <span style="color:#000">id</span> = <span style="color:#000">shmget</span>(<span style="color:#000">IPC_PRIVATE</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>, (<span style="color:#000">SHM_R</span>|<span style="color:#000">SHM_W</span>|<span style="color:#000">IPC_CREAT</span>));  
  
    <span style="color:#00f">if</span> (<span style="color:#000">id</span> == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">shmget(%uz) failed</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">size</span>);  
        <span style="color:#00f">return</span> <span style="color:#000">NGX_ERROR</span>;  
    }  
  
    <span style="color:#000">ngx_log_debug1</span>(<span style="color:#000">NGX_LOG_DEBUG_CORE</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#3af">0</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">shmget id: %d</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">id</span>);  
  
    <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> = <span style="color:#000">shmat</span>(<span style="color:#000">id</span>, <span style="color:#000">NULL</span>, <span style="color:#3af">0</span>);  
  
    <span style="color:#00f">if</span> (<span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> == (<span style="color:#00f">void</span> *) -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>, <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">shmat() failed</span><span style="color:#5a2">&#34;</span>);  
    }  
  
    <span style="color:#00f">if</span> (<span style="color:#000">shmctl</span>(<span style="color:#000">id</span>, <span style="color:#000">IPC_RMID</span>, <span style="color:#000">NULL</span>) == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">shmctl(IPC_RMID) failed</span><span style="color:#5a2">&#34;</span>);  
    }  
  
    <span style="color:#00f">return</span> (<span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span> == (<span style="color:#00f">void</span> *) -<span style="color:#3af">1</span>) ? <span style="color:#000">NGX_ERROR</span> : <span style="color:#000">NGX_OK</span>;  
}  
  
  
<span style="color:#00f">void</span>  
<span style="color:#000">ngx_shm_free</span>(<span style="color:#000">ngx_shm_t</span> *<span style="color:#000">shm</span>)  
{  
    <span style="color:#00f">if</span> (<span style="color:#000">shmdt</span>(<span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span>) == -<span style="color:#3af">1</span>) {  
        <span style="color:#000">ngx_log_error</span>(<span style="color:#000">NGX_LOG_ALERT</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">log</span>, <span style="color:#000">ngx_errno</span>,  
                      <span style="color:#5a2"></span><span style="color:#5a2">&#34;</span><span style="color:#5a2">shmdt(%p) failed</span><span style="color:#5a2">&#34;</span>, <span style="color:#000">shm</span>-&gt;<span style="color:#000">addr</span>);  
    }  
}  
  
<span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">endif  </span><span style="color:#888;font-style:italic">
</span></code></pre></div><p>上面的代码即是 Nginx 源代码中的 src/os/unix/ngx_shemem.c 的全部内容。可见，整个文件只是为了提供两个接口：ngx_shm_alloc 和ngx_shm_free。而这两个接口的实现，按如下逻辑来决定：</p>
<ol>
<li>如果当前系统的 mmap 系统调用支持 MAP_ANON 选项，则使用带 MAP_ANON 选项的mmap。</li>
<li>如果 1 不满足，则如果当前系统 mmap 系统调用支持映射 /dev/zero 设备，则使用 mmap 映射 /dev/zero 的方式来实现。</li>
<li>如果上面 1 和 2 都不满足，且如果当前系统支持 shmget 系统调用的话，则使用该系统调用来实现。</li>
</ol>
<p>看到这里，也许大家就有疑问了，如果当前 3 个条件都不满足怎么办，那就没辙了，<code>ngx_shm_alloc</code> 接口没有相应的定义，只能在链接的时候就不成功了。</p>
<p>另外，关于上面三种情况的判断，都是通过相应的宏是否定义来进行的，而相应的宏的定义，是在auto/unix 脚本中进行的，该脚本会写一端测试程序来判断相应的系统调用是否支持，如果支持，则在 configure 后自动生成的 objs/ngx_auto_config.h 文件中定义对应的宏。</p>
<h2 id="3-channel-机制和共享内存在-nginx-中的使用情况">3. channel 机制和共享内存在 Nginx 中的使用情况</h2>
<p>前面讲 Nginx 中的 channel 机制时提到，Nginx 虽然提供了这种机制，但目前很少用到，而共享内存却相对用的比较多了。例如，为了统计 Nginx 总体的 http 请求处理情况，需要跨越多个 worker 来计算，Nginx 自带的 http 模块 ngx_http_stub_status_module 即主要依赖共享内存的方式。</p></div>

  </article>
</main>
<footer>
  <div>
    <div>
      2011-2020 strider. <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC-BY-4.0</a></div>
  </div>
</footer>
</body>
</html>
