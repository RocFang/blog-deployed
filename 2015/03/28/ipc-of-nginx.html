<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Nginx 中的进程间通信 - 纯真年代</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="strider" />
  <meta name="description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：
 套接字（匿名套接字对） 共享内存 信号  本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制 1.1 概述 首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。
" />

  <meta name="keywords" content="程序员, 文学, 生活" />






<meta name="generator" content="Hugo 0.89.4" />


<link rel="canonical" href="https://pureage.info/2015/03/28/ipc-of-nginx.html" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa4b2b9f31b5c6d0b683db81157a9226e17b06e61911791ab547242a4a0556f2.css" integrity="sha256-&#43;ksrnzG1xtC2g9uBFXqSJuF7BuYZEXkatUckKkoFVvI=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="Nginx 中的进程间通信" />
<meta property="og:description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：

套接字（匿名套接字对）
共享内存
信号

本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制
1.1 概述
首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pureage.info/2015/03/28/ipc-of-nginx.html" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2015-03-28T12:39:00+00:00" />
<meta property="article:modified_time" content="2015-03-28T12:39:00+00:00" />

<meta itemprop="name" content="Nginx 中的进程间通信">
<meta itemprop="description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：

套接字（匿名套接字对）
共享内存
信号

本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制
1.1 概述
首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。"><meta itemprop="datePublished" content="2015-03-28T12:39:00+00:00" />
<meta itemprop="dateModified" content="2015-03-28T12:39:00+00:00" />
<meta itemprop="wordCount" content="7229">
<meta itemprop="keywords" content="nginx," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Nginx 中的进程间通信"/>
<meta name="twitter:description" content="我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：

套接字（匿名套接字对）
共享内存
信号

本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。
1. Nginx 中的 channel 通信机制
1.1 概述
首先简单的说一下 Nginx 中 channel 通信的机制。
Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。
我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">纯真年代</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tools/">工具</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/about/">关于</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/index.xml">订阅</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      纯真年代
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/tools/">工具</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/about/">关于</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://pureage.info/index.xml">订阅</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Nginx 中的进程间通信</h1>
      
      <div class="post-meta">
        <time datetime="2015-03-28" class="post-time">
          2015-03-28
        </time>
        
        

        
        

        
        
      </div>
    </header>

    
    

    
    <div class="post-content">
      <p>我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：</p>
<ul>
<li>套接字（匿名套接字对）</li>
<li>共享内存</li>
<li>信号</li>
</ul>
<p>本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。</p>
<h2 id="1-nginx-中的-channel-通信机制">1. Nginx 中的 channel 通信机制</h2>
<h3 id="11-概述">1.1 概述</h3>
<p>首先简单的说一下 Nginx 中 channel 通信的机制。</p>
<p>Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。</p>
<p>我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。</p>
<p>那么，当父进程在调用了 socketpair 创建出一对匿名套接字对(A1,B1)后，fork 出一个子进程，那么此时子进程也继承了这一对套接字对(A2,B2)。在这个基础上，父子进程即可进行通信了。例如，父进程对 A1 进行写操作，子进程可通过 B2 进行相应的读操作；子进程对 B2 进行写操作，父进程可以通过 A1 来进行相应的读操作等等。</p>
<p>我们假设，父进程依次 fork 了 N 个子进程，在每次 fork 之前，均如前所述调用了 socketpair 建立起一个匿名套接字对，这样，父进程与各个子进程之间即可通过各自的套接字对来进行通信。</p>
<p>但是各子进程之间能否使用匿名套接字对来进行通信呢？</p>
<p>我们假设父进程 A 中,它与子进程 B 之间的匿名套接字对为 <code>AB[2]</code>，它与子进程 C 之间的匿名套接字对为 <code>AC[2]</code>。且进程 B 在进程 C 之前被 fork 出来。</p>
<p>对进程 B 而言，当它被 fork 出来后，它就继承了父进程创建的套接字对，这里我们将其命名为 <code>BA[2]</code>，这样父进程通过操作 <code>AB[2]</code>，子进程 B 通过操作 <code>BA[2]</code>，即可实现父子进程 A 和 B 之间的通信。</p>
<p>对进程 C 而言，当它被 fork 出来后，他就继承了父进程穿件的套接字对，这里我们将其命名为 <code>CA[2]</code>，这样父进程通过操作 <code>AC[2]</code>，子进程 C 通过操作 <code>CA[2]</code>，即可实现父子进程 A 和 C 之间的通信。</p>
<p>但 B 和 C 有一点不同。由于 B 进程在 C 之前被 fork，B 进程无法从父进程中继承到父进程与 C 进程之间的匿名套接字对，而 C 进程在后面被 fork 出来，它却从父进程处继承到了父进程与子进程 B 之间的匿名套接字对。</p>
<p>这样，之后被 fork 出来的进程 C，可以通过它从父进程那里继承到的与 B 进程相关联的匿名套接字对来向进程 B 发送消息，但进程 B 却无法向进程 C 发送消息。</p>
<p>当子进程数量比较多时，就会造成这样的情况：即后面的进程拥有前面每一个子进程的匿名套接字，但前面的进程则没有后面任何一个子进程的匿名套接字。</p>
<p>那么这个问题该如何解决呢？这就涉及到进程间传递文件描述符这个话题了。可以参考这里：<a href="http://pureage.info/2015/03/19/passing-file-descriptors.html">进程之间传递文件描述符</a>。一个子进程被 fork 出来后，它可以依次向在它之前被 fork 出来的所有子进程传递自己的描述符（匿名套接字对中的一个)。</p>
<p>通过这种机制，子进程之间也可以进行通信了。</p>
<p>Nginx 中也就是这么做的。</p>
<h3 id="12-nginx-中的具体实现">1.2 Nginx 中的具体实现</h3>
<p>在 ngx_process.c 中，定义了一个全局的数组 <code>ngx_processes</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ngx_process_t</span>    <span class="n">ngx_processes</span><span class="p">[</span><span class="n">NGX_MAX_PROCESSES</span><span class="p">];</span>  
</code></pre></td></tr></table>
</div>
</div><p>其中，<code>ngx_process_t</code> 类型定义为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">ngx_pid_t</span>           <span class="n">pid</span><span class="p">;</span>  
    <span class="kt">int</span>                 <span class="n">status</span><span class="p">;</span>  
    <span class="n">ngx_socket_t</span>        <span class="n">channel</span><span class="err">\</span><span class="p">[</span><span class="mi">2</span><span class="err">\</span><span class="p">];</span>  

    <span class="n">ngx_spawn_proc_pt</span>   <span class="n">proc</span><span class="p">;</span>  
    <span class="kt">void</span>               <span class="o">*</span><span class="n">data</span><span class="p">;</span>  
    <span class="kt">char</span>               <span class="o">*</span><span class="n">name</span><span class="p">;</span>  
  
    <span class="kt">unsigned</span>            <span class="nl">respawn</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>  
    <span class="kt">unsigned</span>            <span class="nl">just_spawn</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>  
    <span class="kt">unsigned</span>            <span class="nl">detached</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>  
    <span class="kt">unsigned</span>            <span class="nl">exiting</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>  
    <span class="kt">unsigned</span>            <span class="nl">exited</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>  
<span class="p">}</span> <span class="n">ngx_process_t</span><span class="p">;</span>  
</code></pre></td></tr></table>
</div>
</div><p>在这里，我们只关心成员 channel 成员，这个两元素的数组即用来存放一个匿名套接字对。</p>
<p>我们假设程序运行后，有 1 个 master 进程和 4 个 worker 进程。那么，对这 5 个进程而言，每个进程都有一个 4 元素的数组 <code>ngx_processes[4]</code>，数组中每个元素都是一个 <code>ngx_process_t</code> 类型的结构体，包含了相应的某个 worker 进程的相关信息。我们这里关心的是每个结构体的 channel 数组成员。</p>
<p>绘制成表如下：
<img src="/img/ipc-4.jpg" alt="ipc-4.jpg"></p>
<p>上表的每一列表示每个进程的 <code>ngx_processes</code> 数组的各个元素的 channel 成员。</p>
<p>其中，master 进程列中的每一个元素，表示master进程与对应的每个 worker 进程之间的匿名套接字对。</p>
<p>而每一个 worker 进程列中的每一个元素，表示该 worker 进程与对应的每个 worker 进程之间的匿名套接字对。当然这只是一个粗略的说法，与真实情况并不完全相符，还有很多细节需要进一步阐述。</p>
<p>我们直接借助《深入剖析 Nginx》，直接看下图的实例：
<img src="/img/ipc-5.jpg" alt="ipc-5.jpg"></p>
<p>再次感谢《深入剖析 Nginx》的作者高群凯，觉得在这里我没法表达的比他更好了。所以下面会引用很多该书中的内容。</p>
<p>在上表中，每一个单元格的内容分别表示 <code>channel[0]</code> 和 <code>channel[1]</code> 的值，-1表示这之前是描述符，但在之后被主动 close() 掉了，0 表示这一直都无对应的描述符，其他数字表示对应的描述符值。</p>
<p>每一列数据都表示该列所对应进程与其他进程进行通信的描述符，如果当前列所对应进程为父进程，那么它与其它进程进行通信的描述符都为 <code>channel[0]</code> (其实 <code>channel[1]</code> 也可以)；如果当前列所对应的进程为子进程，那么它与父进程进行通信的描述符为 <code>channel[1]</code>（注：这里书中说的太简略，应该为如果当前列所对应的进程为子进程，那么它与父进程进行通信的描述符为该进程的 ngx_processes 数组中，与本进程对应的元素中的 <code>channel[1]</code>，在图中即为标粗的对角线部分，即 <code>[-1,7]</code>，<code>[-1,9]</code>，<code>[-1,11]</code>，<code>[-1,13]</code>这四对），与其它子进程进行通信的描述符都为本进程的 <code>ngx_processes</code> 数组中与该其它进程对应元素的 <code>channel[0]</code>。</p>
<p>比如，<code>[3，7]</code> 单元格表示，如果父进程向 worker0 发送消息，需要使用 <code>channel[0]</code>，即描述符 3，实际上 <code>channel[1]</code> 也可以，它的 <code>channel[1]</code> 为 7，没有被 close() 关闭掉，但一直也没有被使用，所以没有影响，不过按道理应该关闭才是。</p>
<p>再比如，<code>[-1，7]</code> 单元格表示如果 worker0 向 master 进程发送消息，需要使用 <code>channel[1]</code>，即描述符 7，它的 <code>channel[0]</code> 为 -1，表示已经 close() 关闭掉了（Nginx某些地方调用 close() 时并没有设置对应变量为 -1，这里只是为了更好的说明，将已经 close() 掉的描述符全部标记为 -1）。</p>
<p>越是后生成的 worker 进程，其 <code>ngx_processes</code> 数组的元素中，<code>channel[0]</code> 与父进程对应的 <code>ngx_processes</code> 数组的元素中的 <code>channel[0]</code> 值相同的越多，因为基本都是继承而来，但前面生成的 worker 进程，其 <code>channel[0]</code> 是通过进程间调用 sendmsg 传递获得的，所以与父进程对应的 <code>channel[0]</code> 不一定相等。比如，如果 worker0 向 worker3 发送消息，需要使用worker0 进程的 <code>ngx_processes[3]</code> 元素的 <code>channel[0]</code>，即描述符 10，而对应 master 进程的 <code>ngx_processes[3]</code> 元素的 <code>channel[0]</code> 却是 12。虽然它们在各自进程里表现为不同的整型数字，但在内核里表示同一个描述符结构，即不管是 worker0 往描述符 10 写数据，还是master 往描述符 12 写数据，worker3 都能通过描述符 13 正确读取到这些数据，至于 worker3 怎么识别它读到的数据是来自 worker0，还是 master，就得靠其他收到的数据特征，比如pid，来做标记区分。</p>
<p>关于上段讲的，一个子进程如何区分接收到的数据是来自哪一个进程，我们可以看一下 Nginx-1.6.2中的一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ngx_int_t</span>  
<span class="nf">ngx_write_channel</span><span class="p">(</span><span class="n">ngx_socket_t</span> <span class="n">s</span><span class="p">,</span> <span class="n">ngx_channel_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span>  
    <span class="n">ngx_log_t</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">ssize_t</span>             <span class="n">n</span><span class="p">;</span>  
    <span class="n">ngx_err_t</span>           <span class="n">err</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">iovec</span>        <span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  
    <span class="k">struct</span> <span class="n">msghdr</span>       <span class="n">msg</span><span class="p">;</span>  
  
<span class="cp">#if (NGX_HAVE_MSGHDR_MSG_CONTROL)  
</span><span class="cp"></span>  
    <span class="k">union</span> <span class="p">{</span>  
        <span class="k">struct</span> <span class="n">cmsghdr</span>  <span class="n">cm</span><span class="p">;</span>  
        <span class="kt">char</span>            <span class="n">space</span><span class="p">[</span><span class="n">CMSG_SPACE</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))];</span>  
    <span class="p">}</span> <span class="n">cmsg</span><span class="p">;</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
  
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_control</span> <span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cmsg</span><span class="p">;</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmsg</span><span class="p">);</span>  
  
        <span class="n">ngx_memzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmsg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmsg</span><span class="p">));</span>  
  
        <span class="n">cmsg</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">cmsg_len</span> <span class="o">=</span> <span class="n">CMSG_LEN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  
        <span class="n">cmsg</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">cmsg_level</span> <span class="o">=</span> <span class="n">SOL_SOCKET</span><span class="p">;</span>  
        <span class="n">cmsg</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">cmsg_type</span> <span class="o">=</span> <span class="n">SCM_RIGHTS</span><span class="p">;</span>  
  
        <span class="cm">/*  
</span><span class="cm">         * We have to use ngx_memcpy() instead of simple  
</span><span class="cm">         *   *(int *) CMSG_DATA(&amp;cmsg.cm) = ch-&gt;fd;  
</span><span class="cm">         * because some gcc 4.4 with -O2/3/s optimization issues the warning:  
</span><span class="cm">         *   dereferencing type-punned pointer will break strict-aliasing rules  
</span><span class="cm">         *  
</span><span class="cm">         * Fortunately, gcc with -O1 compiles this ngx_memcpy()  
</span><span class="cm">         * in the same simple assignment as in the code above  
</span><span class="cm">         */</span>  
  
        <span class="n">ngx_memcpy</span><span class="p">(</span><span class="n">CMSG_DATA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmsg</span><span class="p">.</span><span class="n">cm</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  
    <span class="p">}</span>  
  
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
  
<span class="cp">#else  
</span><span class="cp"></span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_accrights</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_accrightslen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
  
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_accrights</span> <span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>  
        <span class="n">msg</span><span class="p">.</span><span class="n">msg_accrightslen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  
    <span class="p">}</span>  
  
<span class="cp">#endif  
</span><span class="cp"></span>  
    <span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">ch</span><span class="p">;</span>  
    <span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>  
  
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="n">iov</span><span class="p">;</span>  
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
  
    <span class="n">n</span> <span class="o">=</span> <span class="n">sendmsg</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">err</span> <span class="o">=</span> <span class="n">ngx_errno</span><span class="p">;</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NGX_EAGAIN</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">return</span> <span class="n">NGX_AGAIN</span><span class="p">;</span>  
        <span class="p">}</span>  
  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&#34;sendmsg() failed&#34;</span><span class="p">);</span>  
        <span class="k">return</span> <span class="n">NGX_ERROR</span><span class="p">;</span>  
    <span class="p">}</span>  
  
    <span class="k">return</span> <span class="n">NGX_OK</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>在调用时，参数 ch 即为发送的数据部分，其类型定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>  
     <span class="n">ngx_uint_t</span>  <span class="n">command</span><span class="p">;</span>  
     <span class="n">ngx_pid_t</span>   <span class="n">pid</span><span class="p">;</span>  
     <span class="n">ngx_int_t</span>   <span class="n">slot</span><span class="p">;</span>  
     <span class="n">ngx_fd_t</span>    <span class="n">fd</span><span class="p">;</span>  
<span class="p">}</span> <span class="n">ngx_channel_t</span><span class="p">;</span>  
</code></pre></td></tr></table>
</div>
</div><p>可见，其中就包含了发送方的pid。</p>
<p>最后，就目前 Nginx 代码来看，子进程并没有往父进程发送任何消息，子进程之间也没有相互通信的逻辑。也许是因为 Nginx 有其他一些更好的进程通信方式，比如共享内存等，所以这种 channel 通信目前仅作为父进程往子进程发送消息使用。但由于有这个架构在，可以很轻松使用 channel 机制来完成各进程间的通信任务。</p>
<h3 id="13-nginx-中的相关代码流程">1.3 Nginx 中的相关代码流程</h3>
<p>下面，将上面所讲的内容，在 Nginx 代码中的流程，大概梳理一遍。本文所有代码片段，均来自于nginx-1.6.2。</p>
<p>首先是 main 函数调用 <code>ngx_master_process_cycle</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="k">if</span> <span class="p">(</span><span class="n">ngx_process</span> <span class="o">==</span> <span class="n">NGX_PROCESS_SINGLE</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_single_process_cycle</span><span class="p">(</span><span class="n">cycle</span><span class="p">);</span>  
  
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
        <span class="n">ngx_master_process_cycle</span><span class="p">(</span><span class="n">cycle</span><span class="p">);</span>  
    <span class="p">}</span>  
  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
</code></pre></td></tr></table>
</div>
</div><p>ngx_master_process_cycle<code>调用</code>ngx_start_worker_processes`：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ccf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ngx_core_conf_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ngx_get_conf</span><span class="p">(</span><span class="n">cycle</span><span class="o">-&gt;</span><span class="n">conf_ctx</span><span class="p">,</span> <span class="n">ngx_core_module</span><span class="p">);</span>  
  
<span class="n">ngx_start_worker_processes</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ccf</span><span class="o">-&gt;</span><span class="n">worker_processes</span><span class="p">,</span>  
                           <span class="n">NGX_PROCESS_RESPAWN</span><span class="p">);</span>  
<span class="n">ngx_start_cache_manager_processes</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</code></pre></td></tr></table>
</div>
</div><p>在 <code>ngx_start_worker_processes</code> 函数中，完成对所有 worker 进程的 fork 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>  
<span class="nf">ngx_start_worker_processes</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">ngx_int_t</span> <span class="n">type</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">ngx_int_t</span>      <span class="n">i</span><span class="p">;</span>  
    <span class="n">ngx_channel_t</span>  <span class="n">ch</span><span class="p">;</span>  
  
    <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_NOTICE</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;start worker processes&#34;</span><span class="p">);</span>  
  
    <span class="n">ngx_memzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ngx_channel_t</span><span class="p">));</span>  
  
    <span class="n">ch</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">NGX_CMD_OPEN_CHANNEL</span><span class="p">;</span>  
  
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
  
        <span class="n">ngx_spawn_process</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_worker_process_cycle</span><span class="p">,</span>  
                          <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">intptr_t</span><span class="p">)</span> <span class="n">i</span><span class="p">,</span> <span class="s">&#34;worker process&#34;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>  
  
        <span class="n">ch</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">ngx_process_slot</span><span class="p">].</span><span class="n">pid</span><span class="p">;</span>  
        <span class="n">ch</span><span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">ngx_process_slot</span><span class="p">;</span>  
        <span class="n">ch</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">ngx_process_slot</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
  
        <span class="n">ngx_pass_open_channel</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>上述代码调用的 <code>ngx_spawn_process</code> 即完成具体的 <code>socketpair()</code> 操作和 fork 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ngx_pid_t</span>  
<span class="nf">ngx_spawn_process</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_spawn_proc_pt</span> <span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>  
     <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">ngx_int_t</span> <span class="n">respawn</span><span class="p">)</span>  
<span class="p">{</span>  
       <span class="p">......</span>  
       <span class="k">if</span> <span class="p">(</span><span class="n">socketpair</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">channel</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                          <span class="s">&#34;socketpair() failed while spawning </span><span class="se">\&#34;</span><span class="s">%s</span><span class="se">\&#34;</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>  
            <span class="k">return</span> <span class="n">NGX_INVALID_PID</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="p">......</span>  
        <span class="n">ngx_channel</span> <span class="o">=</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  
        <span class="p">......</span>  
        <span class="n">ngx_process_slot</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>  
        <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>  
        <span class="p">......</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>在上一段代码中可以看到，master 进程在调用 socketpair 后，将生成的 <code>channel[1]</code> 保存在全局变量 <code>ngx_channel</code> 中，<code>ngx_channel</code> 全局变量的作用是，子进程中会使用该全局变量，并加入到自己的事件集中，达到的效果即是子进程将 <code>channel[1]</code> 加入到自己的事件集中。</p>
<p>话分两头，我们先来具体看看子进程的流程。</p>
<p>在主进程执行完 fork 之后，<code>ngx_start_worker_processes</code> 会调用 proc 回调：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">   <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>  
  
    <span class="k">switch</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>  
  
    <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;fork() failed while spawning </span><span class="se">\&#34;</span><span class="s">%s</span><span class="se">\&#34;</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>  
        <span class="n">ngx_close_channel</span><span class="p">(</span><span class="n">ngx_processes</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">channel</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">);</span>  
        <span class="k">return</span> <span class="n">NGX_INVALID_PID</span><span class="p">;</span>  
  
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>  
        <span class="n">ngx_pid</span> <span class="o">=</span> <span class="n">ngx_getpid</span><span class="p">();</span>  
        <span class="n">proc</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>  
        <span class="k">break</span><span class="p">;</span>  
  
    <span class="k">default</span><span class="o">:</span>  
        <span class="k">break</span><span class="p">;</span>  
    <span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>其中，proc 即为 <code>ngx_worker_process_cycle</code>。<code>ngx_worker_process_cycle</code> 会调用<code>ngx_worker_process_init</code> 函数，子进程将从父进程处继承到的 <code>channel[1]</code> 加入到自己的事件集中，就是在这个函数中完成的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>  
<span class="nf">ngx_worker_process_init</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_int_t</span> <span class="n">worker</span><span class="p">)</span>  
<span class="p">{</span>  
<span class="p">......</span>  
   <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">ngx_last_process</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
  
        <span class="k">if</span> <span class="p">(</span><span class="n">ngx_processes</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">continue</span><span class="p">;</span>  
        <span class="p">}</span>  
  
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">ngx_process_slot</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">continue</span><span class="p">;</span>  
        <span class="p">}</span>  
  
        <span class="k">if</span> <span class="p">(</span><span class="n">ngx_processes</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">continue</span><span class="p">;</span>  
        <span class="p">}</span>  
  
        <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">ngx_processes</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
            <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                          <span class="s">&#34;close() channel failed&#34;</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">ngx_processes</span><span class="p">[</span><span class="n">ngx_process_slot</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;close() channel failed&#34;</span><span class="p">);</span>  
    <span class="p">}</span>  
  
<span class="cp">#if 0</span><span class="c">  
</span><span class="c">    ngx_last_process = 0;  
</span><span class="c"></span><span class="cp">#endif  
</span><span class="cp"></span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">ngx_add_channel_event</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_channel</span><span class="p">,</span> <span class="n">NGX_READ_EVENT</span><span class="p">,</span>  
                              <span class="n">ngx_channel_handler</span><span class="p">)</span>  
        <span class="o">==</span> <span class="n">NGX_ERROR</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="cm">/* fatal */</span>  
        <span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">......</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>具体的将 <code>channel[1]</code> 添加到事件集中的操作，是由 <code>ngx_add_channel_event</code> 来完成的，对应的回调处理函数为 <code>ngx_channel_handler</code>，同时我们看到，在添加之前，还进行了很多 close 的工作，这就于之前的示例表里，那些描述符为 -1 的表项相对应了。</p>
<p>此时，子进程已经将从父进程那里继承来的 <code>channel[1]</code> 加入到了自己的监听事件集中，这样，一个子进程从自己的 <code>ngx_processses</code> 数组中，对应本进程的那一个元素中的 <code>channel[1]</code> 中，即可读取来自其他进程的消息。收到消息时，将执行设置好的回调函数<code>ngx_channel_handler</code>，把接收到的新子进程的相关信息存储在自己的全局变量<code>ngx_processes</code> 数组内。见下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>  
<span class="nf">ngx_channel_handler</span><span class="p">(</span><span class="n">ngx_event_t</span> <span class="o">*</span><span class="n">ev</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="p">......</span>  
          <span class="k">case</span> <span class="nl">NGX_CMD_OPEN_CHANNEL</span><span class="p">:</span>  
  
            <span class="n">ngx_log_debug3</span><span class="p">(</span><span class="n">NGX_LOG_DEBUG_CORE</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  
                           <span class="s">&#34;get channel s:%i pid:%P fd:%d&#34;</span><span class="p">,</span>  
                           <span class="n">ch</span><span class="p">.</span><span class="n">slot</span><span class="p">,</span> <span class="n">ch</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">ch</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>  
  
            <span class="n">ngx_processes</span><span class="p">[</span><span class="n">ch</span><span class="p">.</span><span class="n">slot</span><span class="p">].</span><span class="n">pid</span> <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="n">pid</span><span class="p">;</span>  
            <span class="n">ngx_processes</span><span class="p">[</span><span class="n">ch</span><span class="p">.</span><span class="n">slot</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>  
            <span class="k">break</span><span class="p">;</span>  
    <span class="p">......</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>我们再回到父进程中。</p>
<p>父进程在从 <code>ngx_spawn_process</code> 返回后，回来继续执行 <code>ngx_start_worker_processes</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>  
<span class="nf">ngx_start_worker_processes</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_int_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">ngx_int_t</span> <span class="n">type</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">ngx_int_t</span>      <span class="n">i</span><span class="p">;</span>  
    <span class="n">ngx_channel_t</span>  <span class="n">ch</span><span class="p">;</span>  
  
    <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_NOTICE</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;start worker processes&#34;</span><span class="p">);</span>  
  
    <span class="n">ngx_memzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ngx_channel_t</span><span class="p">));</span>  
  
    <span class="n">ch</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">NGX_CMD_OPEN_CHANNEL</span><span class="p">;</span>  
  
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
  
        <span class="n">ngx_spawn_process</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_worker_process_cycle</span><span class="p">,</span>  
                          <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">intptr_t</span><span class="p">)</span> <span class="n">i</span><span class="p">,</span> <span class="s">&#34;worker process&#34;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>  
  
        <span class="n">ch</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">ngx_process_slot</span><span class="p">].</span><span class="n">pid</span><span class="p">;</span>  
        <span class="n">ch</span><span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">ngx_process_slot</span><span class="p">;</span>  
        <span class="n">ch</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">ngx_process_slot</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
  
        <span class="n">ngx_pass_open_channel</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>其中的 for 循环即表示，父进程会把刚刚生成的子进程的 <code>channel[0]</code>，放在一条<strong>消息</strong>的内容中发送给之前生成的子进程。<strong>消息</strong>的格式定义为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>  
     <span class="n">ngx_uint_t</span>  <span class="n">command</span><span class="p">;</span>  
     <span class="n">ngx_pid_t</span>   <span class="n">pid</span><span class="p">;</span>  
     <span class="n">ngx_int_t</span>   <span class="n">slot</span><span class="p">;</span>  
     <span class="n">ngx_fd_t</span>    <span class="n">fd</span><span class="p">;</span>  
<span class="p">}</span> <span class="n">ngx_channel_t</span><span class="p">;</span>  
</code></pre></td></tr></table>
</div>
</div><p>我们看下 <code>ngx_pass_open_channel</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>  
<span class="nf">ngx_pass_open_channel</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="n">ngx_channel_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">ngx_int_t</span>  <span class="n">i</span><span class="p">;</span>  
  
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ngx_last_process</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
  
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ngx_process_slot</span>  
            <span class="o">||</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>  
            <span class="o">||</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="k">continue</span><span class="p">;</span>  
        <span class="p">}</span>  
  
        <span class="n">ngx_log_debug6</span><span class="p">(</span><span class="n">NGX_LOG_DEBUG_CORE</span><span class="p">,</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  
                      <span class="s">&#34;pass channel s:%d pid:%P fd:%d to s:%i pid:%P fd:%d&#34;</span><span class="p">,</span>  
                      <span class="n">ch</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span>  
                      <span class="n">i</span><span class="p">,</span> <span class="n">ngx_processes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pid</span><span class="p">,</span>  
                      <span class="n">ngx_processes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  
  
        <span class="cm">/* TODO: NGX_AGAIN */</span>  
  
        <span class="n">ngx_write_channel</span><span class="p">(</span><span class="n">ngx_processes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  
                          <span class="n">ch</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ngx_channel_t</span><span class="p">),</span> <span class="n">cycle</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>从该函数定义中，可以很清晰的看到“往之前生成的每个进程发送消息”。对之前的每个子进程，具体消息发送工作，是由函数 <code>ngx_write_channel</code> 完成的。</p>
<p><code>ngx_write_channel</code> 函数的第一个参数是之前某个进程从 master 进程继承来的 <code>channel[0]</code>，第二个参数是发送的内容。其中包含了当前进程的 pid、slot号、command 等信息，最重要的是，包含了当前子进程的 <code>channel[0]</code>，其实是实现了一个简单的协议。注意，当前子进程的 <code>channel[0]</code> 虽然存在 <code>ngx_channel_t</code> 类型的消息体中，但真正文件描述符的传递操作，是 <code>ngx_write_channel</code> 通过发送控制信息来完成的。接收进程虽然在接收到的消息体中获得了发送进程的 <code>channel[0]</code> 这个值，但并不能直接使用，必须根据控制信息来获取一个新的文件描述符。参看<a href="jin_cheng_jian_chuan_di_wen_jian_miao_shu_fu.md">进程间传递文件描述符</a>。</p>
<p>至此，父子进程间的配合，使得所有的子进程均拥有了其他子进程的 <code>channel[0]</code>，而另一方面，由于所有子进程的 <code>channel[1]</code> 已加入到自己的监听事件集，所以子进程之间的通信通道即被建立起来。</p>
<p>值得一提的是，父进程在调用 socketpair() 产生一个匿名套接字对后，再 fork 出一个子进程，那么现在有 4 个文件描述符了。其实对这 4 个文件描述符中的任何一个进行写入，从其他3个描述符中的任何一个均可以进行读取操作。</p>
<p>但 Nginx 通过一些 close() 操作，有意达到这样一种目的：</p>
<ul>
<li>对任何一个子进程，其 <code>ngx_processes</code> 数组中，对应其它进程的元素，其 <code>channel[0]</code> 用来向“该其他进程”发送消息。</li>
<li>对任何一个子进程，其 <code>ngx_processes</code> 数组中，对应本进程的元素，其 <code>channel[1]</code> 用来接收来自其他进程的消息，这个其他进程既包括其他子进程，也包括 master 进程。至于如何区分是来自哪个进程，以及该消息是用来做什么的，则通过判断 ngx_channel_t 类型的消息的comman、pid、slot等成员来协商。</li>
<li>对 master 进程，其 <code>ngx_processes</code> 数组的中，对应相应子进程的元素的 <code>channel[0]</code>，用来向该子进程发送消息。注:其实 <code>channel[1]</code> 也可以，但按常理，master 进程的 <code>ngx_processes</code> 数组所有元素的 <code>channel[1]</code> 应该关闭的。</li>
</ul>
<h2 id="2-nginx-中的共享内存">2. Nginx 中的共享内存</h2>
<h3 id="21-概述">2.1 概述</h3>
<blockquote>
<p>共享内存是 Linux 下提供的最基本的进程间通信方法，它通过 mmap 或者 shmget 系统调用在内存中创建了一块连续的线性地址空间，而通过 munmap 或者 shmdt 系统调用可以释放这块内存。使用共享内存的好处是当多个进程使用同一块共享内存时，在任何一个进程修改了共享内存中的内容后，其他进程通过访问这段共享内存都能够得到修改后的内容。</p>
<p>陶辉《深入理解Nginx》</p>
</blockquote>
<p>共享内存可以说是最有用的进程间通信方式，也是最快的 IPC 形式。两个不同进程 A、B 共享内存的意思是，同一块物理内存被映射到进程 A、B 各自的进程地址空间。进程 A 可以即时看到进程 B 对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</p>
<p>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>Linux 中，共享内存可以通过两个系统系统调用来获得，mmap 和shmget，分别属于不同的标准，这不在本文的关注范围之内。mmap 语义上比 shmget 更通用，因为它最一般的做法，是将一个打开的实体文件，映射到一段连续的内存中，各个进程可以根据各自的权限对该段内存进行相应的读写操作，其他进程则可以看到其他进程写入的结果。而 shmget 在语义上相当于是匿名的 mmap，即不关注实体文件，直接在内存中开辟这块共享区域，mmap 通过设置调用时的参数，也可达到这种效果，一种方法是映射 /dev/zero 设备,另一种是使用 MAP_ANON选 项。至于 mmap 和 shmget 的效率，跟不同的内核实现相关，不在本文关注范围内。</p>
<p>除了上面的简单描述外，本文不打算仔细介绍 mmap 和 shmget 的使用。有如下相关资料可以参考：</p>
<ol>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html">Linux环境进程间通信（五）: 共享内存（上）</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html">Linux环境进程间通信（五）: 共享内存（下）</a></li>
<li>APUE,14.8,15.9</li>
</ol>
<h3 id="22-nginx-中的实现">2.2 Nginx 中的实现</h3>
<p>那么，在 Nginx 中，到底是选用 mmap 映射到 /dev/null，还是使用 MAP_ANON 选项调用mmap，或者是使用 shmget 呢？看相关实现的代码就会一目了然：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*  
</span><span class="cm"> * Copyright (C) Igor Sysoev  
</span><span class="cm"> * Copyright (C) Nginx, Inc.  
</span><span class="cm"> */</span>  
  
  
<span class="cp">#include</span> <span class="cpf">&lt;ngx_config.h&gt;  </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;ngx_core.h&gt;  </span><span class="cp">
</span><span class="cp"></span>  
  
<span class="cp">#if (NGX_HAVE_MAP_ANON)  
</span><span class="cp"></span>  
<span class="n">ngx_int_t</span>  
<span class="nf">ngx_shm_alloc</span><span class="p">(</span><span class="n">ngx_shm_t</span> <span class="o">*</span><span class="n">shm</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>  
                                <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span>  
                                <span class="n">MAP_ANON</span><span class="o">|</span><span class="n">MAP_SHARED</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;mmap(MAP_ANON|MAP_SHARED, %uz) failed&#34;</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>  
        <span class="k">return</span> <span class="n">NGX_ERROR</span><span class="p">;</span>  
    <span class="p">}</span>  
  
    <span class="k">return</span> <span class="n">NGX_OK</span><span class="p">;</span>  
<span class="p">}</span>  
  
  
<span class="kt">void</span>  
<span class="nf">ngx_shm_free</span><span class="p">(</span><span class="n">ngx_shm_t</span> <span class="o">*</span><span class="n">shm</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;munmap(%p, %uz) failed&#34;</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
  
<span class="cp">#elif (NGX_HAVE_MAP_DEVZERO)  
</span><span class="cp"></span>  
<span class="n">ngx_int_t</span>  
<span class="nf">ngx_shm_alloc</span><span class="p">(</span><span class="n">ngx_shm_t</span> <span class="o">*</span><span class="n">shm</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">ngx_fd_t</span>  <span class="n">fd</span><span class="p">;</span>  
  
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/zero&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;open(</span><span class="se">\&#34;</span><span class="s">/dev/zero</span><span class="se">\&#34;</span><span class="s">) failed&#34;</span><span class="p">);</span>  
        <span class="k">return</span> <span class="n">NGX_ERROR</span><span class="p">;</span>  
    <span class="p">}</span>  
  
    <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span>  
                                <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;mmap(/dev/zero, MAP_SHARED, %uz) failed&#34;</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>  
    <span class="p">}</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;close(</span><span class="se">\&#34;</span><span class="s">/dev/zero</span><span class="se">\&#34;</span><span class="s">) failed&#34;</span><span class="p">);</span>  
    <span class="p">}</span>  
  
    <span class="k">return</span> <span class="p">(</span><span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="o">?</span> <span class="nl">NGX_ERROR</span> <span class="p">:</span> <span class="n">NGX_OK</span><span class="p">;</span>  
<span class="p">}</span>  
  
  
<span class="kt">void</span>  
<span class="nf">ngx_shm_free</span><span class="p">(</span><span class="n">ngx_shm_t</span> <span class="o">*</span><span class="n">shm</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;munmap(%p, %uz) failed&#34;</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
  
<span class="cp">#elif (NGX_HAVE_SYSVSHM)  
</span><span class="cp"></span>  
<span class="cp">#include</span> <span class="cpf">&lt;sys/ipc.h&gt;  </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;  </span><span class="cp">
</span><span class="cp"></span>  
  
<span class="n">ngx_int_t</span>  
<span class="nf">ngx_shm_alloc</span><span class="p">(</span><span class="n">ngx_shm_t</span> <span class="o">*</span><span class="n">shm</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="kt">int</span>  <span class="n">id</span><span class="p">;</span>  
  
    <span class="n">id</span> <span class="o">=</span> <span class="n">shmget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">SHM_R</span><span class="o">|</span><span class="n">SHM_W</span><span class="o">|</span><span class="n">IPC_CREAT</span><span class="p">));</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;shmget(%uz) failed&#34;</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>  
        <span class="k">return</span> <span class="n">NGX_ERROR</span><span class="p">;</span>  
    <span class="p">}</span>  
  
    <span class="n">ngx_log_debug1</span><span class="p">(</span><span class="n">NGX_LOG_DEBUG_CORE</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;shmget id: %d&#34;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>  
  
    <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">shmat</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span> <span class="s">&#34;shmat() failed&#34;</span><span class="p">);</span>  
    <span class="p">}</span>  
  
    <span class="k">if</span> <span class="p">(</span><span class="n">shmctl</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;shmctl(IPC_RMID) failed&#34;</span><span class="p">);</span>  
    <span class="p">}</span>  
  
    <span class="k">return</span> <span class="p">(</span><span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">NGX_ERROR</span> <span class="p">:</span> <span class="n">NGX_OK</span><span class="p">;</span>  
<span class="p">}</span>  
  
  
<span class="kt">void</span>  
<span class="nf">ngx_shm_free</span><span class="p">(</span><span class="n">ngx_shm_t</span> <span class="o">*</span><span class="n">shm</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">shmdt</span><span class="p">(</span><span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">ngx_log_error</span><span class="p">(</span><span class="n">NGX_LOG_ALERT</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">,</span> <span class="n">ngx_errno</span><span class="p">,</span>  
                      <span class="s">&#34;shmdt(%p) failed&#34;</span><span class="p">,</span> <span class="n">shm</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
  
<span class="cp">#endif  
</span></code></pre></td></tr></table>
</div>
</div><p>上面的代码即是 Nginx 源代码中的 src/os/unix/ngx_shemem.c 的全部内容。可见，整个文件只是为了提供两个接口：ngx_shm_alloc 和ngx_shm_free。而这两个接口的实现，按如下逻辑来决定：</p>
<ol>
<li>如果当前系统的 mmap 系统调用支持 MAP_ANON 选项，则使用带 MAP_ANON 选项的mmap。</li>
<li>如果 1 不满足，则如果当前系统 mmap 系统调用支持映射 /dev/zero 设备，则使用 mmap 映射 /dev/zero 的方式来实现。</li>
<li>如果上面 1 和 2 都不满足，且如果当前系统支持 shmget 系统调用的话，则使用该系统调用来实现。</li>
</ol>
<p>看到这里，也许大家就有疑问了，如果当前 3 个条件都不满足怎么办，那就没辙了，<code>ngx_shm_alloc</code> 接口没有相应的定义，只能在链接的时候就不成功了。</p>
<p>另外，关于上面三种情况的判断，都是通过相应的宏是否定义来进行的，而相应的宏的定义，是在auto/unix 脚本中进行的，该脚本会写一端测试程序来判断相应的系统调用是否支持，如果支持，则在 configure 后自动生成的 objs/ngx_auto_config.h 文件中定义对应的宏。</p>
<h2 id="3-channel-机制和共享内存在-nginx-中的使用情况">3. channel 机制和共享内存在 Nginx 中的使用情况</h2>
<p>前面讲 Nginx 中的 channel 机制时提到，Nginx 虽然提供了这种机制，但目前很少用到，而共享内存却相对用的比较多了。例如，为了统计 Nginx 总体的 http 请求处理情况，需要跨越多个 worker 来计算，Nginx 自带的 http 模块 ngx_http_stub_status_module 即主要依赖共享内存的方式。</p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">strider</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2015-03-28
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://pureage.info/tags/nginx/">nginx</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/2015/06/25/nginx-proxy-cache-and-etag.html">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">nginx proxy_cache 与 etag 配合的问题</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/2015/03/19/passing-file-descriptors.html">
            <span class="next-text nav-default">进程间传递文件描述符</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  


<a href="https://pureage.info/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2011 -
    2022
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        strider
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
