<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>linux下获取本地ip的几种方法 - 纯真年代</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="linux下获取本地ip的几种方法" />
<meta property="og:description" content="1.调用getifaddrs


The getifaddrs() function first appeared in glibc 2.3, but before glibc 2.3.3, the implementation supported only IPv4 addresses; IPv6 support was added in glibc 2.3.3.  Support of address families other than IPv4 is available only on kernels that support netlink.

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pureage.info/2013/12/04/155.html" />
<meta property="article:published_time" content="2013-12-04T08:06:00&#43;00:00"/>
<meta property="article:modified_time" content="2013-12-04T08:06:00&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="linux下获取本地ip的几种方法"/>
<meta name="twitter:description" content="1.调用getifaddrs


The getifaddrs() function first appeared in glibc 2.3, but before glibc 2.3.3, the implementation supported only IPv4 addresses; IPv6 support was added in glibc 2.3.3.  Support of address families other than IPv4 is available only on kernels that support netlink.

"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" /><script src="/js/main.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title">纯真年代</h1>
	<div class="site-description"><nav class="nav social">
			<ul class="flat"></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">首页</a>
			</li>
			
			<li>
				<a href="/post">归档</a>
			</li>
			
			<li>
				<a href="/about">关于</a>
			</li>
			
			<li>
				<a href="/tags">标签</a>
			</li>
			
			<li>
				<a href="/tools">工具</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">linux下获取本地ip的几种方法</h1>
			<div class="meta">Posted at &mdash; Dec 4, 2013</div>
		</div>

		<div class="markdown">
			<h2 id="1-调用getifaddrs">1.调用getifaddrs</h2>

<blockquote>
<p>The getifaddrs() function first appeared in glibc 2.3, but before glibc 2.3.3, the implementation supported only IPv4 addresses; IPv6 support was added in glibc 2.3.3.  Support of address families other than IPv4 is available only on kernels that support netlink.</p>
</blockquote>
<div class="highlight">e></div>
<h2 id="2-调用ioctl">2.调用ioctl</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">int getlocaladdrs(char ip_addrs[][IP_ADDRESS_SIZE], \  
	const int max_count, int *count)  
{  
	int s;  
	struct ifconf ifconf;  
	struct ifreq ifr[32];  
	int if_count;  
	int i;  
	int result;  
  
	*count = 0;  
	s = socket(AF_INET, SOCK_STREAM, 0);  
	if (s &lt; 0)  
	{  
		logError(&#34;file: &#34;__FILE__&#34;, line: %d, &#34; \  
			&#34;socket create fail, errno: %d, error info: %s&#34;, \  
			__LINE__, errno, STRERROR(errno));  
		return errno != 0 ? errno : EMFILE;  
	}  
  
	ifconf.ifc_buf = (char *) ifr;  
	ifconf.ifc_len = sizeof(ifr);  
	if (ioctl(s, SIOCGIFCONF, &amp;ifconf) &lt; 0)  
	{  
		result = errno != 0 ? errno : EMFILE;  
		logError(&#34;file: &#34;__FILE__&#34;, line: %d, &#34; \  
			&#34;call ioctl fail, errno: %d, error info: %s&#34;, \  
			__LINE__, result, STRERROR(result));  
 		close(s);  
		return result;  
	}  
  
	if_count = ifconf.ifc_len / sizeof(ifr[0]);  
	if (max_count &lt; if_count)  
	{  
		logError(&#34;file: &#34;__FILE__&#34;, line: %d, &#34; \  
			&#34;max_count: %d &lt; iterface count: %d&#34;, \  
			__LINE__, max_count, if_count);  
 		close(s);  
		return ENOSPC;  
	}  
  
	for (i = 0; i &lt; if_count; i++)  
	{  
		struct sockaddr_in *s_in;  
    		s_in = (struct sockaddr_in *) &amp;ifr[i].ifr_addr;  
    		if (!inet_ntop(AF_INET, &amp;s_in-&gt;sin_addr, \  
			ip_addrs[*count], IP_ADDRESS_SIZE))  
		{  
			result = errno != 0 ? errno : EMFILE;  
			logError(&#34;file: &#34;__FILE__&#34;, line: %d, &#34; \  
				&#34;call inet_ntop fail, &#34; \  
				&#34;errno: %d, error info: %s&#34;, \  
				__LINE__, result, STRERROR(result));  
 			close(s);  
			return result;  
    		}  
		(*count)++;  
	}  
  
	close(s);  
	return *count &gt; 0 ? 0 : ENOENT;  
}  </pre></div>
<h2 id="3-判断一个ip是否是本地ip的几种方法">3.判断一个ip是否是本地ip的几种方法：</h2>

<p>（1）用该ip和指定一个端口号，执行bind操作，成功则说明是本地IP，否则不是。</p>

<p>（2）上一种方法的问题在于，如果指定的端口被占用了，那么及时是本地Ip，bind也会出错。可以做如下修改：bind时指定0端口，让系统给分配一个可用的端口。</p>

<p>（3）先用上面提到的获取本地Ip的两种方法把本地ip列表获取到，然后看目标ip是否在其中即可。</p>
		</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = '';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div><a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


</body>
</html>
