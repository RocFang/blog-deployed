<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="strider (方鹏)">
<meta name="description" content="一个伪文青兼程序员的自嗨
    ">
<meta name="keywords" content="博客, 技术, 文学, 电影">
<meta name="referrer" content="always">
<title>O_EXCL 的作用 - 纯真年代</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://pureage.info/">纯真年代</a></h1><h2><a href="https://pureage.info/">阅读、体验、沉淀...</a></h2>
  </div>
  <nav><a href="/">博客</a><a href="/tools/">工具</a><a href="/about/">关于</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>O_EXCL 的作用</h1>
  </div>
<div class="meta">
  <div>2013-12-25</div>
  <div>
    <span><a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98">#程序员</a></span>
    </div>
  </div>
<div class="content">
  <h2 id="1-原始语义">1. 原始语义</h2>
<p>与 O_CREATE 标志组合起来调用 open，确保指定的文件由 open 的调用者创建，否则返回错误。即，如果进程 A 用 O_CREATE 和 O_EXCL 标志来调用 open，期望创建一个指定的文件 file1，如果 file1 不存在，则 open 成功返回且创建 file1，如果 file1 已经存在了（即不是由进程 A 创建的），那么 open 返回错误。</p>
<h2 id="2-使用场景">2. 使用场景</h2>
<p><code>O_CREATE|O_EXCL</code> 多用于确保一个一个程序只能执行单个进程，不能执行多个进程。原理如下，假设进程 A 是某程序的一个实例，如果它用 <code>O_CREATE|O_EXCL</code> 标志能够成功创建指定的文件，说明它是该程序的唯一实例，可以继续执行；如果返回错误，说明该文件已经存在，进而说明系统中已经运行着一个该程序的其它实例，检测到错误的返回值后，该实例就可以退出了。</p>
<p><strong>之所以能这么用的唯一理由是该操作是原子的</strong>。</p>
<p>之所以这么说，理由如下。假设同样语义的非原子的操作流程如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">if</span>( <span style="color:#000">access</span>(<span style="color:#000">file</span>, <span style="color:#000">R_OK</span>) == -<span style="color:#3af">1</span> )   <span style="color:#888;font-style:italic">/* 首先检查文件是否存在 */</span>  
    <span style="color:#000">open</span>(<span style="color:#000">file</span>, <span style="color:#000">O_RDWR</span> | <span style="color:#000">O_CREAT</span><span style="color:#f00">，</span><span style="color:#3af">0666</span>);  <span style="color:#888;font-style:italic">/* 如果不存在，那我创建一个这样的文件 */</span>  
...  <span style="color:#888;font-style:italic">/* 继续执行任务 */</span>  
</code></pre></div><p>由于判断文件是否存在与创建文件是两个步骤，就会存在临界竞争的问题。试想下面的场景：</p>
<ol>
<li>某程序的进程 A 判断文件不存在，因此 A 认为自己是此时系统中该程序唯一的实例，准备继续执行创建指定的文件。</li>
<li>操作系统的调度策略恰好在此时起作用，进程 A 暂停执行。此时指定的文件还没有创建。</li>
<li>该程序的另一个进程 B 开始执行，同样，由于指定的文件不存在，B 也认为自己是此时系统中该程序的唯一实例，准备继续执行创建指定的文件。</li>
<li>这样，进程 A 和进程 B 都能成功调用 open 并继续往下执行。</li>
<li>此时系统中就同时运行着该程序的两个实例，与仅运行一个进程的期望不符。</li>
</ol>
<p>所以说，O_EXCL 与 O_CREATE 联合使用的前提就是该操作是原子的。</p>
<h2 id="3-非原子操作如何达到同样目的">3. 非原子操作如何达到同样目的</h2>
<p>假设现在不能使用 <code>O_EXCL|O_CREATE</code>，或者假设用 <code>O_EXCL|O_CREATE</code> 调用 open 并不是原子的，该如何达到上面关于“一个程序只能运行一个实例”的要求呢？</p>
<p>可以用系统调用 link 来实现。</p>
<p>link的原型如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> <span style="color:#888;font-style:italic">#</span><span style="color:#888;font-style:italic">include</span> <span style="color:#888;font-style:italic">&lt;unistd.h&gt;  </span><span style="color:#888;font-style:italic">
</span><span style="color:#888;font-style:italic"></span>  
 <span style="color:#00f">int</span> <span style="color:#000">link</span>(<span style="color:#00f">const</span> <span style="color:#00f">char</span> *<span style="color:#000">oldpath</span>, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *<span style="color:#000">newpath</span>);  
</code></pre></div><p>link 的作用是为 oldpath 指定的源文件创建一个 newpath 指定的链接文件（硬链接，hard link）。如果创建成功，则返回 0，如果 newpath 路径指定的目标文件在调用 link 前已经存在，则 link 会错误返回。</p>
<p>根据 link 的特点，可以达到上面的要求：</p>
<ol>
<li>首先确保文件系统中已经有一个源文件 file1。</li>
<li>某程序的一个进程 A 开始执行，调用 link，试图创建一个 file1 的链接文件 file2。</li>
<li>如果 A 调用 link 成功，说明该程序此时只有进程A锁定了该文件，进程 A 可以继续往下执行。</li>
<li>由于进程 A 为 file1 创建了一个链接文件 file2，此时 file1 的链接数是 2（用 stat 可获取链接数）。</li>
<li>进程 B 调用 link，同样试图创建 file1 的链接文件 file2，但由于 file2 已经存在，link 错误返回。可进一步调用 stat 系统调用，查看 file1 的链接数，确定该链接数是 2。</li>
<li>进程 B 退出。</li>
</ol>
<h2 id="4-o_exclo_create-确实有可能是非原子的">4. O_EXCL|O_CREATE 确实有可能是非原子的</h2>
<p>在 NFS 上，<code>O_EXCL|O_CREATE</code> 确实有可能是非原子的：</p>
<blockquote>
<p>On NFS, O_EXCL is supported only when using NFSv3 or later on  kernel 2.6 or later.  In NFS environments where O_EXCL support  is not provided, programs that rely on it for performing  locking tasks will contain a race condition.</p>
</blockquote>
<p>在这种情况下，上面讨论的使用 link 的方法就有了用武之地。如上引文所述，在最新的内核中， NFS 中并不存在该问题，用 <code>O_EXCL|O_CREATE</code> 仍然能满足要求。</p>
<h2 id="5--其它">5.  其它</h2>
<p>O_EXCL 一般只能和 O_CREATE 一起使用，不能单独使用，但有一个例外：在 2.6 及以后的内核中，如果 open 指定的文件是一个块设备文件，O_EXCL 可以单独使用，此时，如果该块设备正在被使用（例如已经被挂载)，那么 open 将失败返回，错误码是 EBUSY；除此之外，单独使用 O_EXCL 的后果无法预知：</p>
<blockquote>
<p>In general, the behavior of O_EXCL is undefined if it is used  without O_CREAT.  There is one exception: on Linux 2.6 and later, O_EXCL can be used without O_CREAT if pathname refers to a block device.  If the block device is in use by the system (e.g., mounted), open() fails with the error EBUSY.</p>
</blockquote></div>

  </article>
</main>
<footer>
  <div>
    <div>2011-2020 strider. <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC-BY-4.0</a><p>Powered by <a href="https://gohugo.io/">Hugo</a> with <a href="https://github.com/yanlinlin82/simple-style">Simple-Style</a></div>
  </div>
</footer>
</body>
</html>
