<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nginx on 纯真年代</title>
    <link>https://pureage.info/tags/nginx/</link>
    <description>Recent content in nginx on 纯真年代</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 04 Jul 2016 15:17:00 +0000</lastBuildDate>
    
	<atom:link href="https://pureage.info/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>代码中的谎言</title>
      <link>https://pureage.info/2016/07/04/lies-in-code.html</link>
      <pubDate>Mon, 04 Jul 2016 15:17:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/07/04/lies-in-code.html</guid>
      <description>俗话说，一个谎言，要用一百个谎言去圆。 在代码的世界里，同样如此。当然，这里只是借用“谎言”这个概念，并不带有任何贬义色彩。“谎言”用来指代那</description>
    </item>
    
    <item>
      <title>关于Nginx-1.9.11的动态模块</title>
      <link>https://pureage.info/2016/02/14/nginx-dynamic-module.html</link>
      <pubDate>Sun, 14 Feb 2016 14:57:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/02/14/nginx-dynamic-module.html</guid>
      <description>我们知道，原生 Nginx 增加、修改一个第三方模块，需要重新编译源代码，所有的模块都是用静态链接的形式组织起来的。而 Tengine 有一个增强的功能，即动态模块加载</description>
    </item>
    
    <item>
      <title>使用ngx.header修改Accept-Ranges的问题</title>
      <link>https://pureage.info/2016/01/17/modify-accept-ranges-header.html</link>
      <pubDate>Sun, 17 Jan 2016 14:09:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/01/17/modify-accept-ranges-header.html</guid>
      <description>今天有位朋友在使用 OpenResty 时发现一个奇怪的事情。 他打算用 ngx.header 来修改响应的 Accept-Ranges 头，于是按照惯例做法，在 *_by_lua 脚本中写入ngx.header[&amp;ldquo;A</description>
    </item>
    
    <item>
      <title>如何绘制流程图和结构图</title>
      <link>https://pureage.info/2016/01/12/flow-chart.html</link>
      <pubDate>Tue, 12 Jan 2016 14:38:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/01/12/flow-chart.html</guid>
      <description>经常会看到一些技术博客在讲解代码的时候，能配上一幅幅精美的程序流程图、结构图，一直都很佩服这样的作者。其实他们大多数也并没有使用什么特别的工</description>
    </item>
    
    <item>
      <title>accept与epoll惊群</title>
      <link>https://pureage.info/2015/12/22/thundering-herd.html</link>
      <pubDate>Tue, 22 Dec 2015 07:01:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/22/thundering-herd.html</guid>
      <description>今天打开 OneNote,发现里面躺着一篇很久以前写的笔记，现在将它贴出来。 1. 什么叫惊群现象 首先，我们看看维基百科对惊群的定义: The thundering herd problem occurs when a</description>
    </item>
    
    <item>
      <title>尝鲜：Nginx-1.9.8推出的切片模块</title>
      <link>https://pureage.info/2015/12/10/nginx-slice-module.html</link>
      <pubDate>Thu, 10 Dec 2015 06:12:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/10/nginx-slice-module.html</guid>
      <description>熟悉 CDN 行业主流技术的朋友应该都比较清楚，虽然 Nginx 近几年发展的如日中天，但是基本上没有直接使用它自带的 proxy_cache 模块来做缓存的，原因有很多，例如下面几个</description>
    </item>
    
    <item>
      <title>Nginx紧急发布1.9.9修复bug</title>
      <link>https://pureage.info/2015/12/10/bugfix-of-nginx.html</link>
      <pubDate>Thu, 10 Dec 2015 03:27:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/10/bugfix-of-nginx.html</guid>
      <description>有时候，仔细追踪一个项目的各次提交也是蛮有趣的，特别是各种 Bugfix，会发现，原来牛人也会有各种低级错误。 例如，Nginx 刚在12月8号发</description>
    </item>
    
    <item>
      <title>Nginx对Connection头的处理过程</title>
      <link>https://pureage.info/2015/12/08/connection-header-in-nginx.html</link>
      <pubDate>Tue, 08 Dec 2015 07:04:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/08/connection-header-in-nginx.html</guid>
      <description>1. 标准 RFC2616 中，对 Connection 的说明如下： HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s),</description>
    </item>
    
    <item>
      <title>不规范的 Nginx 开发</title>
      <link>https://pureage.info/2015/11/11/non-standard-nginx-programming.html</link>
      <pubDate>Wed, 11 Nov 2015 09:55:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/11/11/non-standard-nginx-programming.html</guid>
      <description>最近这一年多， 见识过很多基于 Nginx 开发的项目， 在这个过程中也遇到了几个很常见的不规范的做法。 离主分支过远 Nginx 是一个很有生命力的项目， 不断的在开发一</description>
    </item>
    
    <item>
      <title>nginx proxy_cache与etag配合的问题</title>
      <link>https://pureage.info/2015/06/25/nginx-proxy-cache-and-etag.html</link>
      <pubDate>Thu, 25 Jun 2015 13:07:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/06/25/nginx-proxy-cache-and-etag.html</guid>
      <description>首先谈谈遇到的问题: 一个Nginx架在一个后端服务的前面，Nginx proxy_pass到它并开启proxy_cache,假设这个后端服务总</description>
    </item>
    
    <item>
      <title>Nginx中的进程间通信</title>
      <link>https://pureage.info/2015/03/28/ipc-of-nginx.html</link>
      <pubDate>Sat, 28 Mar 2015 12:39:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/03/28/ipc-of-nginx.html</guid>
      <description>我们知道,Linux提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中Ngi</description>
    </item>
    
    <item>
      <title>进程间传递文件描述符</title>
      <link>https://pureage.info/2015/03/19/passing-file-descriptors.html</link>
      <pubDate>Thu, 19 Mar 2015 08:46:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/03/19/passing-file-descriptors.html</guid>
      <description>首先，必须声明，“进程间传递文件描述符”这个说法是错误的。 在处理文件时，内核空间和用户空间使用的主要对象是不同的。对用户程序来说，一个文件由</description>
    </item>
    
    <item>
      <title>Nginx如何控制某个特性是否打开</title>
      <link>https://pureage.info/2014/10/17/nginx-configure-of-define-and-have.html</link>
      <pubDate>Fri, 17 Oct 2014 09:31:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/10/17/nginx-configure-of-define-and-have.html</guid>
      <description>提到Nginx，大家首先会想到它的高性能，异步框架、模块化、upstream、红黑树等耳熟能详的技术实现。这些确实也是Nginx的核心，但作</description>
    </item>
    
    <item>
      <title>用proxy_intercept_errors和recursive_error_pages代理多次302</title>
      <link>https://pureage.info/2014/08/25/hiding-302-using-proxy-pass.html</link>
      <pubDate>Mon, 25 Aug 2014 15:59:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/08/25/hiding-302-using-proxy-pass.html</guid>
      <description>302是HTTP协议中的一个经常被使用状态码，是多种重定向方式的一种，其语义经常被解释为“Moved Temporarily”。这里顺带提一下</description>
    </item>
    
    <item>
      <title>ngx.var.arg与ngx.req.get_uri_args的区别</title>
      <link>https://pureage.info/2014/07/30/two-kinds-of-variables-in-ngx-lua.html</link>
      <pubDate>Wed, 30 Jul 2014 10:30:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/07/30/two-kinds-of-variables-in-ngx-lua.html</guid>
      <description>ngx.var.arg_xx与ngx.req.get_uri_args[&amp;ldquo;xx&amp;rdquo;]两者都是为了获取请求uri中的参数</description>
    </item>
    
    <item>
      <title>春哥关于Nginx踩坑记（一）的回复</title>
      <link>https://pureage.info/2014/04/30/answer-of-nginx-pitfall-1-by-agentzh.html</link>
      <pubDate>Wed, 30 Apr 2014 02:42:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/04/30/answer-of-nginx-pitfall-1-by-agentzh.html</guid>
      <description>对于Nginx踩坑记（一），在openresty的google group上提了个问题：ngx.exec是如何处理上层定义的变量的 春哥的回复摘</description>
    </item>
    
    <item>
      <title>Nginx踩坑记（一）</title>
      <link>https://pureage.info/2014/04/26/pitfall-of-nginx.html</link>
      <pubDate>Sat, 26 Apr 2014 13:18:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/04/26/pitfall-of-nginx.html</guid>
      <description>1. 预备知识 Nginx有两种定义变量的方法，一种是在模块中定义，从而成为内建变量；另一种是在配置文件中通过set指令来定义。 配置过Nginx的</description>
    </item>
    
    <item>
      <title>关于nginx中的host变量</title>
      <link>https://pureage.info/2014/02/22/host-variable-in-nginx.html</link>
      <pubDate>Fri, 21 Feb 2014 19:51:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/02/22/host-variable-in-nginx.html</guid>
      <description>关于变量host，在Nginx的官网wiki中是如下说明的： $host：in this order of precedence: host name from the request line, or host name from the “Host” request header field, or the server name matching a request 直</description>
    </item>
    
    <item>
      <title>lua-nginx使用自定义变量中需要说明的一点</title>
      <link>https://pureage.info/2014/01/20/lua-nginx-variable.html</link>
      <pubDate>Mon, 20 Jan 2014 15:30:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/01/20/lua-nginx-variable.html</guid>
      <description>在nginx中，有两种方式添加自定义的变量： 在配置文件中用set指定添加 在自己编写的C模块中，调用ngx_http_add_variable</description>
    </item>
    
    <item>
      <title>关于proxy_pass的参数路径问题</title>
      <link>https://pureage.info/2013/10/31/130.html</link>
      <pubDate>Thu, 31 Oct 2013 04:16:00 +0000</pubDate>
      
      <guid>https://pureage.info/2013/10/31/130.html</guid>
      <description>由于工作需要，开始分析nginx的proxy模块，在分析之前，当然要先会用了。于是开始熟悉该模块的一些指令，其中最基本的指令要属proxy_</description>
    </item>
    
  </channel>
</rss>