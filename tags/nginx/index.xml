<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nginx on 纯真年代</title>
    <link>https://pureage.info/tags/nginx/</link>
    <description>Recent content in nginx on 纯真年代</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 28 May 2021 15:32:35 +0800</lastBuildDate><atom:link href="https://pureage.info/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nginx 中的 X-Accel-Redirect 响应头</title>
      <link>https://pureage.info/post/x-accel-redirect-header-in-nginx/</link>
      <pubDate>Fri, 28 May 2021 15:32:35 +0800</pubDate>
      
      <guid>https://pureage.info/post/x-accel-redirect-header-in-nginx/</guid>
      <description>&lt;p&gt;在 Nginx 的 ngx_http_proxy_module 的&lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&#34;&gt;使用说明&lt;/a&gt;中，有对 &lt;code&gt;X-Accel-Redirect&lt;/code&gt; 的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“X-Accel-Redirect” performs an &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html#internal&#34;&gt;internal redirect&lt;/a&gt; to the specified URI;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文就简单的描述一下在某种特殊场景下 &lt;code&gt;X-Accel-Redirect&lt;/code&gt; 的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>代码中的谎言</title>
      <link>https://pureage.info/2016/07/04/lies-in-code.html</link>
      <pubDate>Mon, 04 Jul 2016 15:17:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/07/04/lies-in-code.html</guid>
      <description>&lt;p&gt;俗话说，一个谎言，要用一百个谎言去圆。&lt;/p&gt;
&lt;p&gt;在代码的世界里，同样如此。当然，这里只是借用“谎言”这个概念，并不带有任何贬义色彩。“谎言”用来指代那些由于设计或理解上的小疏漏，因为这些小疏漏，导致后续的代码里使用很多迂回的策略来达到目的。&lt;/p&gt;
&lt;p&gt;但是代码世界里的“谎言”，又与真实世界的“谎言”截然不同，因为我们有版本管理系统在背后默默的记录着一切。通过它，我们可以对“谎言”进行追根溯源，找到最初的疏漏。&lt;/p&gt;
&lt;p&gt;今天我们就来以 &lt;a href=&#34;https://github.com/arut/nginx-rtmp-module&#34;&gt;Nginx-RTMP&lt;/a&gt; 这个项目为例，来“拆穿”它的一个设计精巧的“谎言”。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于 Nginx-1.9.11 的动态模块</title>
      <link>https://pureage.info/2016/02/14/nginx-dynamic-module.html</link>
      <pubDate>Sun, 14 Feb 2016 14:57:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/02/14/nginx-dynamic-module.html</guid>
      <description>&lt;p&gt;我们知道，原生 Nginx 增加、修改一个第三方模块，需要重新编译源代码，所有的模块都是用静态链接的形式组织起来的。而 Tengine 有一个增强的功能，即动态模块加载 DSO(Dynamic Shared Objects)，可以实现运行时动态加载模块，而不用每次都要重新编译Tengine。&lt;/p&gt;
&lt;p&gt;在 2016 年农历春节期间，Nginx 官方发布了最新版本 Nginx-1.9.11，也增加了该功能。&lt;/p&gt;
&lt;p&gt;Nginx-1.9.11 的Changelog 如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Changes with nginx 1.9.11                                        09 Feb 2016&lt;/p&gt;
&lt;p&gt;*) Feature: TCP support in resolver.&lt;/p&gt;
&lt;p&gt;*) Feature: dynamic modules.&lt;/p&gt;
&lt;p&gt;*) Bugfix: the $request_length variable did not include size of request&lt;br&gt;
headers when using HTTP/2.&lt;/p&gt;
&lt;p&gt;*) Bugfix: in the ngx_http_v2_module.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从使用的角度上来说，是增加了一个指令 &lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#load_module&#34;&gt;load_modules&lt;/a&gt; 指令，来加载编译为 so 形式的动态模块。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 ngx.header 修改 Accept-Ranges 的问题</title>
      <link>https://pureage.info/2016/01/17/modify-accept-ranges-header.html</link>
      <pubDate>Sun, 17 Jan 2016 14:09:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/01/17/modify-accept-ranges-header.html</guid>
      <description>&lt;p&gt;今天有位朋友在使用 OpenResty 时发现一个奇怪的事情。&lt;/p&gt;
&lt;p&gt;他打算用 &lt;code&gt;ngx.header&lt;/code&gt; 来修改响应的 Accept-Ranges 头，于是按照惯例做法，在 &lt;code&gt;*_by_lua&lt;/code&gt;  脚本中写入 &lt;code&gt;ngx.header[&amp;quot;Accept-Ranges&amp;quot;] = &amp;quot;xxx&amp;quot;&lt;/code&gt;。在 OpenResty 中，这是一种经常被使用到的方法。&lt;/p&gt;
&lt;p&gt;他发现的问题是，当这么修改后，真实响应的 Accept-Ranges 头不是被改写了，而是出现了两个并列的 Accept-Ranges 头，其中第一个的值是他打算修改的值，而第二个 Accept-Ranges 头的值却是原始的值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何绘制流程图和结构图</title>
      <link>https://pureage.info/2016/01/12/flow-chart.html</link>
      <pubDate>Tue, 12 Jan 2016 14:38:00 +0000</pubDate>
      
      <guid>https://pureage.info/2016/01/12/flow-chart.html</guid>
      <description>&lt;p&gt;经常会看到一些技术博客在讲解代码的时候，能配上一幅幅精美的程序流程图、结构图，一直都很佩服这样的作者。其实他们大多数也并没有使用什么特别的工具，基本上可以分为如下几类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft Viso、Word、PPT、Windows 自带的画图板等常用办公软件&lt;/li&gt;
&lt;li&gt;一些其他相对较小众的绘图软件，例如 Pencil&lt;/li&gt;
&lt;li&gt;脑图工具，例如 Xmind&lt;/li&gt;
&lt;li&gt;Graphviz，使用一种叫 dot 的语言来描述结构并生成图片&lt;/li&gt;
&lt;li&gt;利用最基本的字符(连字符，箭头等)来绘制，这种做法第一眼就会给人一种返璞归真的感觉，但实际上我个人并不习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这几类绘制结构图、流程图的方法或工具，我基本上都使用过，但绘图水平实在太差，效率也很低。在读代码的时候，大部分是靠笔、纸这种最原始的工具来完成分析，甚至还专门买了一个白板放在家里。这样往往几幅图画下来后，自己是弄得很明白了，却没法分享到文章里去。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>accept 与 epoll 惊群</title>
      <link>https://pureage.info/2015/12/22/thundering-herd.html</link>
      <pubDate>Tue, 22 Dec 2015 07:01:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/22/thundering-herd.html</guid>
      <description>&lt;p&gt;今天打开 OneNote，发现里面躺着一篇很久以前写的笔记，现在将它贴出来。&lt;/p&gt;
&lt;h2 id=&#34;1-什么叫惊群现象&#34;&gt;1. 什么叫惊群现象&lt;/h2&gt;
&lt;p&gt;首先，我们看看&lt;a href=&#34;http://en.wikipedia.org/wiki/Thundering_herd_problem&#34;&gt;维基百科对惊群的定义&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The thundering herd problem occurs when a large number of processes waiting for an event are awoken when that event occurs, but only one process is able to proceed at a time. After the processes wake up, they all demand the resource and a decision must be made as to which process can continue. After the decision is made, the remaining processes are put back to sleep, only to all wake up again to request access to the resource.&lt;/p&gt;
&lt;p&gt;This occurs repeatedly, until there are no more processes to be woken up. Because all the processes use system resources upon waking, it is more efficient if only one process was woken up at a time.&lt;/p&gt;
&lt;p&gt;This may render the computer unusable, but it can also be used as a technique if there is no other way to decide which process should continue (for example when programming with semaphores).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>尝鲜：Nginx-1.9.8 推出的切片模块</title>
      <link>https://pureage.info/2015/12/10/nginx-slice-module.html</link>
      <pubDate>Thu, 10 Dec 2015 06:12:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/10/nginx-slice-module.html</guid>
      <description>&lt;p&gt;熟悉 CDN 行业主流技术的朋友应该都比较清楚，虽然 Nginx 近几年发展的如日中天，但是基本上没有直接使用它自带的 proxy_cache 模块来做缓存的，原因有很多，例如下面几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能不好（相对于 ATS 等专业的 cache 软件）&lt;/li&gt;
&lt;li&gt;不支持裸设备&lt;/li&gt;
&lt;li&gt;大文件不会切片&lt;/li&gt;
&lt;li&gt;大文件的 Range 请求表现不尽如人意&lt;/li&gt;
&lt;li&gt;Nginx 自身不支持合并回源&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Nginx 紧急发布 1.9.9 修复 bug</title>
      <link>https://pureage.info/2015/12/10/bugfix-of-nginx.html</link>
      <pubDate>Thu, 10 Dec 2015 03:27:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/10/bugfix-of-nginx.html</guid>
      <description>&lt;p&gt;有时候，仔细追踪一个项目的各次提交也是蛮有趣的，特别是各种 Bugfix，会发现，原来牛人也会有各种低级错误。&lt;/p&gt;
&lt;p&gt;例如，Nginx 刚在 12 月 8 号发布了 nginx-1.9.8，马上就又发布 nginx-1.9.9，这种密集的发布，一看就是 Bug 修复了。我们看看到底修复了什么 Bug。&lt;/p&gt;
&lt;p&gt;首先，看看changelog：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Changes with nginx 1.9.9 09 Dec 2015&lt;/p&gt;
&lt;p&gt;*) Bugfix: proxying to unix domain sockets did not work when using
variables; the bug had appeared in 1.9.8.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来看看是如何修复的，变更前的代码片段:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx 对 Connection 头的处理过程</title>
      <link>https://pureage.info/2015/12/08/connection-header-in-nginx.html</link>
      <pubDate>Tue, 08 Dec 2015 07:04:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/12/08/connection-header-in-nginx.html</guid>
      <description>&lt;h3 id=&#34;1-标准&#34;&gt;1. 标准&lt;/h3&gt;
&lt;p&gt;RFC2616 中，对 Connection 的说明如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;综合 &lt;a href=&#34;https://tools.ietf.org/html/rfc2616#page-117&#34;&gt;RFC2626 14.10&lt;/a&gt;、《HTTP权威指南》4.3.1、《图解HTTP》6.3.2中的说法，均指明了 Connection 头部（请求头、响应头）主要包括如下两方面的作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;控制不再转发给代理的首部字段&lt;/li&gt;
&lt;li&gt;管理持久连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，我个人经常见到的是第二种用法，对第一种用法还不甚了解。&lt;/p&gt;
&lt;p&gt;第一种用法，大概意思就是，在一个 HTTP 应用（客户端、服务器）将报文转发出之前，必须删除 Connection 首部列出的所有首部字段（多个不同的字段用逗号分隔），当然一些 end-to-end 的头部是肯定不能放进去的，例如 Cache-Control 头。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>不规范的 Nginx 开发</title>
      <link>https://pureage.info/2015/11/11/non-standard-nginx-programming.html</link>
      <pubDate>Wed, 11 Nov 2015 09:55:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/11/11/non-standard-nginx-programming.html</guid>
      <description>&lt;p&gt;最近这一年多，见识过很多基于 Nginx 开发的项目，在这个过程中也遇到了几个很常见的不规范的做法。&lt;/p&gt;
&lt;h2 id=&#34;离主分支过远&#34;&gt;离主分支过远&lt;/h2&gt;
&lt;p&gt;Nginx 是一个很有生命力的项目，不断的在开发一些新的特性，基于这种项目开发的项目，从一开始就要想到版本同步升级的问题。&lt;/p&gt;
&lt;p&gt;Nginx 本身提供了强大的模块开发机制，在做自己的业务开发时，应该尽可能用模块去解决，而不要乱动 Nginx 核心代码。其实，如果不是业务场景特殊，或者对性能有更苛刻的要求，开发者都不应该去修改核心代码。如果实在到了不动核心代码不行或者解决方案非常憋屈的时候，也应该尽量先做好同步升级的方案，比如经常不定期合入主干代码等。连开发阵容强大的 Tengine，都会跟进 Nginx 的更新，你有什么理由不这样做呢。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>nginx proxy_cache 与 etag 配合的问题</title>
      <link>https://pureage.info/2015/06/25/nginx-proxy-cache-and-etag.html</link>
      <pubDate>Thu, 25 Jun 2015 13:07:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/06/25/nginx-proxy-cache-and-etag.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;首先谈谈遇到的问题:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 Nginx 架在一个后端服务的前面，Nginx proxy_pass 到它并开启 proxy_cache，假设这个后端服务总是会吐 Etag 响应头。&lt;/p&gt;
&lt;p&gt;在应用中，我们发现当 Nginx 的 proxy_cache 成功将后端的页面 cache 住时，浏览器多次对该页面发起请求，会命中 Nginx 的 cache，但即使浏览器请求带了 If-None-Match 请求头，Nginx 却不会响应 304，而是响应200。&lt;/p&gt;
&lt;p&gt;这样带来的问题是，即使 Nginx 的 cache 将请求阻挡在后端应用之外，但是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命中后每次响应 200 导致 Nginx 所在的服务器和客户浏览器双方都有流量损耗&lt;/li&gt;
&lt;li&gt;更重要的是增长了服务响应时间。因为，如果是304的话，nginx不需要向浏览器吐数据，只用告诉浏览器用本地的缓存就好了。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Nginx 中的进程间通信</title>
      <link>https://pureage.info/2015/03/28/ipc-of-nginx.html</link>
      <pubDate>Sat, 28 Mar 2015 12:39:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/03/28/ipc-of-nginx.html</guid>
      <description>&lt;p&gt;我们知道，Linux 提供了多种进程间传递消息的方式，比如共享内存、套接字、管道、消息队列、信号等，每种方式都各有特点，各有优缺点。其中 Nginx 主要使用了其中的三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;套接字（匿名套接字对）&lt;/li&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要结合代码讲一下前两种方式，匿名套接字对和共享内存在 Nginx 中的使用。&lt;/p&gt;
&lt;h2 id=&#34;1-nginx-中的-channel-通信机制&#34;&gt;1. Nginx 中的 channel 通信机制&lt;/h2&gt;
&lt;h3 id=&#34;11-概述&#34;&gt;1.1 概述&lt;/h3&gt;
&lt;p&gt;首先简单的说一下 Nginx 中 channel 通信的机制。&lt;/p&gt;
&lt;p&gt;Nginx中的 channel 通信，本质上是多个进程之间，利用匿名套接字(socketpair)对来进行通信。&lt;/p&gt;
&lt;p&gt;我们知道，socketpair 可以创建出一对套接字，在这两个套接字的任何一个上面进行写操作，在另一个套接字上就可以相应的进行读操作，而且这个管道是全双工的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>进程间传递文件描述符</title>
      <link>https://pureage.info/2015/03/19/passing-file-descriptors.html</link>
      <pubDate>Thu, 19 Mar 2015 08:46:00 +0000</pubDate>
      
      <guid>https://pureage.info/2015/03/19/passing-file-descriptors.html</guid>
      <description>&lt;p&gt;首先，必须声明，“进程间传递文件描述符”这个说法是错误的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在处理文件时，内核空间和用户空间使用的主要对象是不同的。对用户程序来说，一个文件由一个文件描述符标识。该描述符是一个整数，在所有有关文件的操作中用作标识文件的参数。文件描述符是在打开文件时由内核分配，只在一个进程内部有效。两个不同进程可以使用同样的文件描述符，但二者并不指向同一个文件。基于同一个描述符来共享文件是不可能的。&lt;br&gt;
《深入理解 Linux 内核架构》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里说的“进程间传递文件描述符”是指，A 进程打开文件 fileA，获得文件描述符为 fdA，现在 A 进程要通过某种方法，根据 fdA，使得另一个进程 B，获得一个新的文件描述符 fdB，这个 fdB 在进程 B 中的作用，跟 fdA 在进程 A 中的作用一样。即在 fdB 上的操作，即是对 fileA 的操作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx 如何控制某个特性是否打开</title>
      <link>https://pureage.info/2014/10/17/nginx-configure-of-define-and-have.html</link>
      <pubDate>Fri, 17 Oct 2014 09:31:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/10/17/nginx-configure-of-define-and-have.html</guid>
      <description>&lt;p&gt;提到 Nginx，大家首先会想到它的高性能、事件框架、模块化、upstream 等耳熟能详的技术实现。这些确实也是 Nginx 的核心，但作为一个优秀的开源项目，Nginx 可以供我们借鉴的远不止这些，例如本文的话题：如何控制某个特性是否打开？&lt;/p&gt;
&lt;p&gt;我们知道，在 Linux 下用源码安装方式编译安装一个软件时，标准情况下是有一个 configure 的动作，这个动作即是在编译前对环境进行检查，服务于后面的编译和安装，Nginx当然也不例外。&lt;/p&gt;
&lt;p&gt;Nginx 的 configure 文件是一个入口，在里面调用了很多其他脚本，这些脚本都位于源代码的    &lt;code&gt;auto&lt;/code&gt; 目录下。本文重点涉及其中两个脚本：&lt;code&gt;auto/have&lt;/code&gt; 和 &lt;code&gt;auto/define&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 proxy_intercept_errors 和 recursive_error_pages 代理多次 302</title>
      <link>https://pureage.info/2014/08/25/hiding-302-using-proxy-pass.html</link>
      <pubDate>Mon, 25 Aug 2014 15:59:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/08/25/hiding-302-using-proxy-pass.html</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;注意：此文写作时间比较久远，请谨慎参考，自行阅读代码、文档以及测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;302 是 HTTP 协议中的一个经常被使用状态码，是多种重定向方式的一种，其语义经常被解释为“Moved Temporarily”。这里顺带提一下，现实中用到的 302 多为误用（与 303，307 混用），在 HTTP/1.1 中，它的语义为“Found”。&lt;/p&gt;
&lt;p&gt;302 有时候很明显，有时候又比较隐蔽。最简单的情况，是当我们在浏览器中输入一个网址 A，然后浏览器地址栏会自动跳到 B，进而打开一个网页，这种情况就很可能是 302。&lt;/p&gt;
&lt;p&gt;比较隐蔽的情况经常发生在嵌入到网页的播放器中。例如，当你打开一个优酷视频播放页面时，抓包观察一下就会经常发现 302 的影子。但由于这些 url 并不是直接在浏览器中打开的，所以在浏览器的地址栏看不到变化，当然，如果将这些具体的url特意挑出来复制到浏览器地址栏里，还是可以观察到的。&lt;/p&gt;
&lt;p&gt;上一段提到了优酷。其实现在多数在线视频网站都会用到 302，原因很简单，视频网站流量一般较大，都会用到 CDN，区别只在于是用自建 CDN 还是商业 CDN。而由于 302 的重定向语义（再重复一遍，302 的语义广泛的被误用，在使用 302 的时候，我们很可能应该使用 303 或 307，但后面都不再纠结这一点），可以与 CDN 中的调度很好的结合起来。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ngx.var.arg 与 ngx.req.get_uri_args 的区别</title>
      <link>https://pureage.info/2014/07/30/two-kinds-of-variables-in-ngx-lua.html</link>
      <pubDate>Wed, 30 Jul 2014 10:30:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/07/30/two-kinds-of-variables-in-ngx-lua.html</guid>
      <description>&lt;p&gt;&lt;code&gt;ngx.var.arg_xx&lt;/code&gt; 与 &lt;code&gt;ngx.req.get_uri_args[&amp;quot;xx&amp;quot;]&lt;/code&gt; 两者都是为了获取请求 uri 中的参数，例如对于 url：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://pureage.info?strider=1  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了获取输入参数 strider，以下两种方法都可以：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;local&lt;/span&gt; strider &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ngx.var.arg_strider
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;local&lt;/span&gt; strider &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ngx.req.get_uri_args[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;strider&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;差别在于，当请求 uri 中有多个同名参数时，&lt;code&gt;ngx.var.arg_xx&lt;/code&gt; 的做法是取第一个出现的值，&lt;code&gt;ngx.req_get_uri_args[&amp;quot;xx&amp;quot;]&lt;/code&gt; 的做法是返回一个 table，该 table 里存放了该参数的所有值，例如,当请求 uri 为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://pureage.info?strider=1&amp;amp;strider=2&amp;amp;strider=3&amp;amp;strider=4  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，&lt;code&gt;ngx.var.arg_strider&lt;/code&gt; 的值为“1”，而 &lt;code&gt;ngx.req.get_uri_args[&amp;quot;strider&amp;quot;]&lt;/code&gt; 的值为 &lt;code&gt;table [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;]&lt;/code&gt;。因此，&lt;code&gt;ngx.req.get_uri_args&lt;/code&gt; 属于&lt;code&gt;ngx.var.arg_&lt;/code&gt; 的增强。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>春哥关于 Nginx 踩坑记（一）的回复</title>
      <link>https://pureage.info/2014/04/30/answer-of-nginx-pitfall-1-by-agentzh.html</link>
      <pubDate>Wed, 30 Apr 2014 02:42:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/04/30/answer-of-nginx-pitfall-1-by-agentzh.html</guid>
      <description>&lt;p&gt;对于 &lt;a href=&#34;http://pureage.info/2014/04/26/pitfall-of-nginx.html&#34;&gt;Nginx踩坑记（一）&lt;/a&gt;，在 openresty 的 google group 上提了个问题：&lt;a href=&#34;https://groups.google.com/forum/#!msg/OpenResty/BHFTTmN366Q/8XMn9UzXuCgJ&#34;&gt;ngx.exec是如何处理上层定义的变量的&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;春哥的回复&lt;strong&gt;摘录&lt;/strong&gt;如下：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx 踩坑记（一）</title>
      <link>https://pureage.info/2014/04/26/pitfall-of-nginx.html</link>
      <pubDate>Sat, 26 Apr 2014 13:18:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/04/26/pitfall-of-nginx.html</guid>
      <description>&lt;h2 id=&#34;1-预备知识&#34;&gt;1. 预备知识&lt;/h2&gt;
&lt;p&gt;Nginx 有两种定义变量的方法，一种是在模块中定义，从而成为内建变量；另一种是在配置文件中通过 set 指令来定义。&lt;/p&gt;
&lt;p&gt;配置过 Nginx 的同学可能都知道这样一个事实：一个请求在其处理过程中，即使经历多个不同的  location 配置块，它使用的还是同一套 Nginx 变量的副本。&lt;/p&gt;
&lt;p&gt;例如，如果有如下的配置：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;location /test1 {  
        set $hello hello;  
        rewrite /test1 /test2 last;

}
  
location /test2 {  
        echo $hello;  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然变量是定义在 location /test1 中，但 Nginx 变量一旦创建，其变量名的可见范围就是整个 Nginx 配置，所以在 /test2 中直接使用该变量是不会报错的。另一方面，由于变量的生命周期是与请求相关的，所以如果直接访问 /test2，得到的变量 &lt;code&gt;$hello&lt;/code&gt; 是一个空值，而访问 /test1，则会内部跳转到 /test2，将 /test1 中赋值的 hello 打印出来。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于 nginx 中的 host 变量</title>
      <link>https://pureage.info/2014/02/22/host-variable-in-nginx.html</link>
      <pubDate>Fri, 21 Feb 2014 19:51:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/02/22/host-variable-in-nginx.html</guid>
      <description>&lt;p&gt;关于变量 host，在 Nginx 的官网 wiki 中是如下说明的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$host：in this order of precedence: host name from the request line, or host name from the “Host” request header field, or the server name matching a request&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直白的翻译一下：host 变量的值按照如下优先级获得：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求行中的 host&lt;/li&gt;
&lt;li&gt;请求头中的 Host 头部&lt;/li&gt;
&lt;li&gt;与一条请求匹配的 server name&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很清楚，有三点，取优先级最高的那个。仅从字面意思上来理解，这个选择的过程为：如果请求行中有 host 信息，则以请求行中的 host 作为 host 变量的值（host 与 host 变量不是一个东西，很拗口）；如果请求行中没有 host 信息，则以请求头中的 Host 头的值作为 host 变量的值；如果前面两者都没有，那么 host 变量就是与该请求匹配所匹配的 serve 名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>lua-nginx 使用自定义变量时需要说明的一点</title>
      <link>https://pureage.info/2014/01/20/lua-nginx-variable.html</link>
      <pubDate>Mon, 20 Jan 2014 15:30:00 +0000</pubDate>
      
      <guid>https://pureage.info/2014/01/20/lua-nginx-variable.html</guid>
      <description>&lt;p&gt;在 Nginx 中，有两种方式添加自定义的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在配置文件中用 set 指定添加&lt;/li&gt;
&lt;li&gt;在自己编写的 C 模块中，调用 &lt;code&gt;ngx_http_add_variable&lt;/code&gt; 接口来添加变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一种方法较简单，第二种方法有一处需要说明一下。&lt;/p&gt;
&lt;p&gt;当调用 &lt;code&gt;ngx_http_add_variable&lt;/code&gt; 接口时，如果传入的 flag 参数中  &lt;code&gt;NGX_HTTP_VAR_NOHASH&lt;/code&gt; 位被设置了，那么在 lua 代码中使用 ngx.var.XXX 是不能访问到该变量的，得到的值是 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下，如果现在配置文件中通过set指定一个中间变量，则在lua代码中可以访问到。&lt;/p&gt;
&lt;p&gt;例如，某个 C 模块中用带有 &lt;code&gt;NGX_HTTP_VAR_NOHASH&lt;/code&gt; 位的 flag 参数调用了  &lt;code&gt;ngx_http_add_variable&lt;/code&gt;，创建了变量 A，则如果在 lua 代码中通过 &lt;code&gt;ngx.var.A&lt;/code&gt; 只能得到一个 &lt;code&gt;nil&lt;/code&gt; 值。&lt;/p&gt;
&lt;p&gt;而如果在配置文件中，先调用 set 命令：&lt;code&gt;set $B $A；&lt;/code&gt;，那么在 lua 代码中，通过代码 &lt;code&gt;local A2 = ngx.var.B&lt;/code&gt; 则可以间接访问到该变量。&lt;/p&gt;
&lt;p&gt;翻了一下邮件列表，发现该问题 agentzh 早有解答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逆雪寒：&lt;!-- raw HTML omitted --&gt;
通过 &lt;code&gt;ngx.var.fastcgi_script_name&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; 。 但 &lt;code&gt;set $fsn $fastcgi_script_name&lt;/code&gt; 然后 &lt;code&gt;ngx.var.fsn&lt;/code&gt; 就能正常获取了。bug  ? 还是我理解问题？&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
