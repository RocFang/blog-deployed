<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>依赖一个RPM来制作新的RPM - 纯真年代</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="依赖一个RPM来制作新的RPM" />
<meta property="og:description" content="项目中有这样一个场景：A软件通过RPM包发布，B软件严重依赖A软件，但在它的基础上有一些业务逻辑的添加和修改。A软件是公司一个历史悠久的产品，且保持频繁的更新，B软件是我在维护。

在开发的时候，很简单，先把某一个稳定版本的A软件安装到开发机上，然后直接进行业务逻辑的开发就可以了。但在发布的时候肯定就不能这么做了，你很难要求运维先去发布服务器上下载一个A软件的rpm包，安装或更新完后，再去发布服务器上下载一个B软件的业务逻辑包，再进行相关的配置。如果是一台机器就罢了，几十上百台服务器这样玩就是作死。所以，我需要做出一个B软件的独立的rpm包，用这个rpm包安装或更新后，直接能进行相关的配置。

再来澄清一下需求：B软件既要严重依赖A软件，但要在A软件上添加很多业务逻辑。但要求在发布的时候脱离对A软件rpm包的依赖。

最简单的方法，当然是先把A软件的代码库做一个分支，或者拷贝出一个新的代码库，在上面进行开发，将B软件与A软件独立开来。这样发布的时候当然就是一个独立的包了。但如前所属，A软件更新频繁，生命力旺盛，我可不想时时来在同步上花时间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pureage.info/2014/01/27/176.html" />
<meta property="article:published_time" content="2014-01-27T03:41:46&#43;00:00"/>
<meta property="article:modified_time" content="2014-01-27T03:41:46&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="依赖一个RPM来制作新的RPM"/>
<meta name="twitter:description" content="项目中有这样一个场景：A软件通过RPM包发布，B软件严重依赖A软件，但在它的基础上有一些业务逻辑的添加和修改。A软件是公司一个历史悠久的产品，且保持频繁的更新，B软件是我在维护。

在开发的时候，很简单，先把某一个稳定版本的A软件安装到开发机上，然后直接进行业务逻辑的开发就可以了。但在发布的时候肯定就不能这么做了，你很难要求运维先去发布服务器上下载一个A软件的rpm包，安装或更新完后，再去发布服务器上下载一个B软件的业务逻辑包，再进行相关的配置。如果是一台机器就罢了，几十上百台服务器这样玩就是作死。所以，我需要做出一个B软件的独立的rpm包，用这个rpm包安装或更新后，直接能进行相关的配置。

再来澄清一下需求：B软件既要严重依赖A软件，但要在A软件上添加很多业务逻辑。但要求在发布的时候脱离对A软件rpm包的依赖。

最简单的方法，当然是先把A软件的代码库做一个分支，或者拷贝出一个新的代码库，在上面进行开发，将B软件与A软件独立开来。这样发布的时候当然就是一个独立的包了。但如前所属，A软件更新频繁，生命力旺盛，我可不想时时来在同步上花时间。"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" /><script src="/js/main.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title">纯真年代</h1>
	<div class="site-description"><nav class="nav social">
			<ul class="flat"></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">首页</a>
			</li>
			
			<li>
				<a href="/posts">归档</a>
			</li>
			
			<li>
				<a href="/about">关于</a>
			</li>
			
			<li>
				<a href="/tags">标签</a>
			</li>
			
			<li>
				<a href="/tags">工具</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">依赖一个RPM来制作新的RPM</h1>
			<div class="meta">Posted at &mdash; Jan 27, 2014</div>
		</div>

		<div class="markdown">
			<p>项目中有这样一个场景：A软件通过RPM包发布，B软件严重依赖A软件，但在它的基础上有一些业务逻辑的添加和修改。A软件是公司一个历史悠久的产品，且保持频繁的更新，B软件是我在维护。</p>

<p>在开发的时候，很简单，先把某一个稳定版本的A软件安装到开发机上，然后直接进行业务逻辑的开发就可以了。但在发布的时候肯定就不能这么做了，你很难要求运维先去发布服务器上下载一个A软件的rpm包，安装或更新完后，再去发布服务器上下载一个B软件的业务逻辑包，再进行相关的配置。如果是一台机器就罢了，几十上百台服务器这样玩就是作死。所以，我需要做出一个B软件的独立的rpm包，用这个rpm包安装或更新后，直接能进行相关的配置。</p>

<p>再来澄清一下需求：B软件既要严重依赖A软件，但要在A软件上添加很多业务逻辑。但要求在发布的时候脱离对A软件rpm包的依赖。</p>

<p>最简单的方法，当然是先把A软件的代码库做一个分支，或者拷贝出一个新的代码库，在上面进行开发，将B软件与A软件独立开来。这样发布的时候当然就是一个独立的包了。但如前所属，A软件更新频繁，生命力旺盛，我可不想时时来在同步上花时间。</p>

<p>第二个方法，制作一个子包。rpm包里有一个subpackage的概念，就是说可以同时生成一个main包和多个subpackage包。子包的制作也很简单，在A包原有的spec文件中，添加%subpackage foo的字样，同样将一下必要的标签，例如%file，都在其后加上foo即可。这个方法很不错，但有几个问题：</p>

<ol>
<li>但需要改动A软件的spec文件，我的原则是尽量不要动A原有的文件，最多在其源码路径SOURCE下添加一两个tar.gz包，而且这几个源码包在A的spec文件中是不会有所体现的。<br /></li>
<li>虽然大部分标签例如%files,%pre,%post等都可以为每个subpackage单独添加，但最重要的标签，%prep,%build和%install确是一个spec文件中只能存在一份。一个解决方法是把业务逻辑的添加放到%post阶段添加。<br />
<br /></li>
</ol>

<p>其实第二个方法已经可以解决我的问题了，但多少都会动A的spec文件，并且subpackage也加一个%files标签，与main package的%files重复，很占地方，导致以后每次main package更新%files标签的时候，subpackage部分的%files也要去更新。虽然查了一下，spec中可以有include命令，可以把公共部分提取到一个外部文件，再分别include进来，但如前所述，我希望尽可能少的去改A的spec文件。本来A只有一个spec文件，现在为了简洁要拆成两个，不能说没对其产生影响。</p>

<p>最后只好采用了第三种方法。</p>

<p>首先，将B的所有业务逻辑放到一个B.tar.gz包里，提交到A的SOURCE目录下，A的spec文件不会去操作这个源码包。注意，为了简便起见，在B.tar.gz中，要有一个Makefile文件，在里面完成install的操作。这样在spec文件中，只用一行语句调用该Makefile即可。</p>

<p>其次，为B软件维护一个脚本。该脚本完成如下工作：将A的spec文件拷贝出来，用sed,awk等进行修改，主要是修改一些Release信息等。最主要的工作是在%install标签下，调用A.tar.gz中的Makefile。</p>

<p>最后，该脚本会去用rpmbuild执行这个新生成的spec文件。在调用时将source目录定义到A的SOURCE目录，如前所属，B.tar.gz就放在这里。</p>

<p>用这种方法，虽然需要维护一个脚本，但最少限度的动用A，又能完全自动的同步A软件包的更新，且生成的是一个B的独立rpm包。目前看来较好的满足的我的需求。</p>
		</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = '';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div><a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


</body>
</html>
